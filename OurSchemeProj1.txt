2017 spring PL project (OurScheme) - Project 1

Due : 3/20 // was : 4/18(¤») midnight (23:59)

  // You are to implement something like the following
                 
  // 'exp' is a pointer that points to a linked list data structure;
  // The linked list data structure results from reading in
  // the user's input.

  Print 'Welcome to OurScheme!'
  Print '\n'
  Print '> '

  repeat
  
    ReadSExp(exp);
    PrintSExp(exp); // You must "pretty print" this S-expression.
    Print '> '
    
  until (OR (user entered '(exit)')
            (END-OF-FILE encountered)
        )

  Print '\n'
  Print 'Thanks for using OurScheme!' // Doesn't matter whether there is an
                                      // '\n' at the end
2. Syntax of OurScheme

terminal :
  LEFT-PAREN       // '('
  RIGHT-PAREN      // ')'
  INT              // e.g., '123', '+123', '-123'
  STRING           // "string's (example)." (strings do not extend across lines)
  DOT              // '.'
  FLOAT            // '123.567', '123.', '.567', '+123.4', '-.123'
  NIL              // 'nil' or '#f', but not 'NIL' nor 'nIL'
  T                // 't' or '#t', but not 'T' nor '#T'
  QUOTE            // '
  SYMBOL           // a consecutive sequence of printable characters that are
                   // not numbers, and do not contain '(', ')', single-quote,
                   // double-quote and white-spaces ; 
                   // Symbols are case-sensitive 
                   // (i.e., uppercase and lowercase are different);

Note :

  With the exception of strings, token are separated by the following "separators" :
    (a) one or more white-spaces
    (b) '('                               (note : '(' is a token by itself)
    (c) ')'                               (note : ')' is a token by itself)
    (d) the single-quote character (')    (note : it is a token by itself)
    (e) the double-quote character (")    (note : it starts a STRING)

Examples :

  '3.25' is a FLOAT.
  '3.25a' is a SYMBOL.
  'a.b' is a SYMBOL.
  '#f' is NIL
  '#fa' (alternatively, 'a#f') is a SYMBOL.

Note :

  '.' can mean several things : 
    it is either part of a FLOAT or part of a SYMBOL or a DOT.
    
  It means a DOT only when it "stands alone".
  
  '#' can also mean two things :
    it is either part of NIL (or T) or part of a SYMBOL.
  
  It is part of NIL (or T) only when it is '#t' or '#f' that "stand alone".
  
<S-exp> ::= <ATOM> 
            | LEFT-PAREN <S-exp> { <S-exp> } [ DOT <S-exp> ] RIGHT-PAREN
            | QUOTE <S-exp>
            
<ATOM>  ::= SYMBOL | INT | FLOAT | STRING 
            | NIL | T | LEFT-PAREN RIGHT-PAREN

Once the attempt to read in an S-expression fails, the line 
containing the error-char is ignored.  Start to read in an 
S-expression from the next input line.

Note : a quoted S-expression '... is the same as (quote ...)

   a. In C, the basic program building block is a statement.
      In OurScheme, the basic program building block is 
      an S-expression (S-exp, for short).
      
   b. An S-exp is either an atom, a list, or a dotted pair.
   
   c. An atom is either an integer (e.g., 123), a float
      (e.g., 12.34 or 12. or .34), a string (e.g., "Hi, there!"), 
      or a symbol (e.g., abc).
      
   d. Abc, abc, aBc, a-B!c?, !??, t, nil are examples of symbols
   
      // Blanks and line-returns ("white-space characters") are 
      // considered delimiters
      
      // Upper case and lower case are different, e.g., aB, AB, Ab,
      // ab are all different symbols.
      
      // Each symbol may or may not be bound to an S-exp.
      
      // When I say that a symbol abc is bound to the S-exp
      // (abc "Hi there" (5 3)),
      // you could take what I mean to be that the "value" of abc
      // is (abc "Hi there" (5 3)).
      
      // "Binding" (rather than "value") is a better way of saying 
      // what the situation really is.  
      
      // t, nil are two system-defined symbols 
      //   (t for "true" and nil for "false")
      // They cannot be bound to any S-exp (i.e., they cannot be 
      // treated like user-defined symbols and cannot have values).
      
      // t is also written as #t, meaning "true"
      // nil is also written as () or #f, meaning "false"
      // In other word,
      //   these two are the same : t   #t
      //   these three are the same : nil   #f   ()
      
      // OurScheme understands both 't' and '#t', but it only prints '#t'
      // OurScheme understands all these three : 'nil', '#f', '()',
      //   but it only prints 'nil'.     
      
      // Side remark :
      //   (True) Scheme uses #t, #f and ()
      //   "Other Lisps" use t, nil and ()
      
   e. An ¡uS-exp sequence¡v is of the form
         S1 S2 S3 ... Sn
      where each Si is an S-exp.
      // e.g., (1) 1 (1 . 1)
      // e.g., 1 2 (3 4 (5))
      // Each of the above S-exp sequence contains three S-exp

   f. A dotted pair is of the form
        (SS1 . S2)
      where S2 is an S-exp, whereas SS1 is an ¡uS-exp sequence¡v.
      // Note that there is a dot between SS1 and S2,
      //      with one or more spaces in between
      // e.g., (1 . 2)
      // e.g., (1  2  3  4  . 5)
      // e.g., (1  2  3  4  . ())
      // e.g., (1 . (2 . (3 . abc)))
      // e.g., (1 2 3 . abc)
      // e.g., ((1) (2 (3)) . (abc))
      // e.g., ((1) (2 (3)) . (nil))
      // e.g., ((1) (2 (3)) . nil)
      
   g. The following notations of dotted pairs are equivalent.
      
      (S1 S2 S3 S4 . S5)
      (S1 . (S2 . (S3 . (S4 . S5))))
      
   h. Comment :
      What we refer to as a "dotted pair" is different from what
      other professionals refer to as a "dotted pair".
      
      What other professionals mean by a dotted pair is just
      (S1 . S2), where S1 and S2 are S-exp.
      
   i. A list is of the form
        (SS1)
      where SS1 is an ¡uS-exp sequence¡v.
      // Note : () is known as "the empty list"
      // For historical reasons, () is defined to be the same
      //   as nil or #f, meaning "false"
      
   j. A list (S1 S2 ... Sn) is actually a short-handed
      notation for the following dotted pair
        (S1 . (S2 . (...(Sn . nil)))...)))
      In other words, a list is actually a special kind of
      dotted pair.
      
      Another way of writing the list (S1 S2 ... Sn) is
        (S1 S2 ... Sn . nil)
        
      // In other word, there are three (seven?) ways for writing
      // the same list.
      //   (S1 S2 S3 S4 S5)
      //   (S1 . (S2 . (S3 . (S4 . (S5 . nil)))))
      //   (S1 . (S2 . (S3 . (S4 . (S5 . #f )))))
      //   (S1 . (S2 . (S3 . (S4 . (S5 . () )))))
      //   (S1 S2 S3 S4 S5 . nil)
      //   (S1 S2 S3 S4 S5 . #f)
      //   (S1 S2 S3 S4 S5 . ())
        
   k. When the system prints out a dotted pair, it
      always tries to print it in list-like format.
      
      For example, if the dotted pair is
        (1 . (2 . (3 . (4 . 5))))
      Then the system prints it as
        (1 2 3 4 . 5)
        
      But if the dotted pair is
        (1 . (2 . (3 . (4 . nil))))
      The system does not print it as
        (1 2 3 4 . nil)
      Instead, the system prints it as
        (1 2 3 4)
   
   l. Line comments
   
   A line comment begins with ';' until the end-of-line.
   This ';' must be such that either it is the very first 
   character of the line or there is a separater preceding this ';'
   on this line. 
   
   (Therefore, for example, 'ab;b' is a symbol,
    while 'ab ;b' is the symbol 'ab' followed by a 
    line comment that starts with ';b'.)
        
3. Here are some examples of what your program should
   do for project 1. (The following assumes that your program
   runs interactively.)

Welcome to OurScheme!

> (1 . (2 . (3 . 4)))
( 1
  2
  3
  .
  4
)

> (1 . (2 . (3 . nil)))
( 1
  2
  3
)

> (1 . (2 . (3 . ())))
( 1
  2
  3
)

> (1 . (2 . (3 . #f)))
( 1
  2
  3
)

> a
a

> t
#t

> #t
#t

> nil
nil

> ()
nil

> #f
nil

> (t () . (1 2 3))
( #t
  nil
  1
  2
  3
)

> (t . nil . (1 2 3))
ERROR (unexpected character) : line 1 column 10 character '.'

> ((1 2 3) . (4 . (5 . nil)))
( ( 1
    2
    3
  )
  4
  5
)

> ((1 2 3) . (4 . (5 . ())))
( ( 1
    2
    3
  )
  4
  5
)

> (12.5       . (4 . 5))
( 12.500
  4
  .
  5
)

> (10 12.())   ; same as : ( 10 12. () )
( 10
  12.000
  nil
)

> (10 ().125)   ; same as : ( 10 () .125 )
( 10
  nil
  0.125
)

> ( 1 2.5)
( 1
  2.500
)

> ( 1 2.a)
( 1
  2.a
)

> (1 2.25.5.a)
( 1
  2.25.5.a
)

> (12 (    . 3))
ERROR (unexpected character) : line 1 column 11 character ' '

> "Hi"
"Hi"

> "(1 . 2   . 3)"
"(1 . 2   . 3)"

> (((1 . 2) 
    . ((3 4) 
       . 
       (5 . 6)
      )
   ) 
   . (7 . 8)
  )
( ( ( 1
      .
      2
    )
    ( 3
      4
    )
    5
    .
    6
  )
  7
  .
  8
)

> ())
nil

> ERROR (unexpected character) : line 1 column 1 character ')'

> (Hi there ! How are you ?)
( Hi
  there
  !
  How
  are
  you
  ?
)

> (Hi there! How are you?)
( Hi
  there!
  How
  are
  you?
)

> (Hi! (How about using . (Lisp (instead of . C?))))
( Hi!
  ( How
    about
    using
    Lisp
    ( instead
      of
      .
      C?
    )
  )
)

> (Hi there) (How are you)
( Hi
  there
)

> ( How
  are
  you
)
         
> (Hi
           .
           (there  .(     ; note that there may be no space between
                          ; '.' and '('
           How is it going?))
           )
( Hi
  there
  How
  is
  it
  going?
)

> ; Note : We have just introduced the use of comments.
  ; ';' starts a comment until the end of line.
  ; A comment is something that ReadSExp() should skip when 
  ; reading in an S-expression.
  
(1 2 3) )
( 1
  2
  3
)

> ERROR (unexpected character) : line 1 column 2 character ')'

> (1 2 
   3) (4 5
( 1
  2
  3
)

>       6)
( 4
  5
  6
)

>        '(Hi
           .
           (there  .(     ; note that there may be no space between
                          ; '.' and '('
           How is it going?))
           )
( quote 
  ( Hi
    there
    How
    is
    it
    going?
  )
)

>'(1 2 3) )
( quote
  ( 1
    2
    3
  )
)

> ERROR (unexpected character) : line 1 column 2 character ')'

> '(1 2 3) .25
( quote
  ( 1
    2
    3
  )
)

> 0.250

> (exit  ; as of now, your system only understands 'exit' ;
      )  ; and the program terminates when it sees '(exit)'

Thanks for using OurScheme!





// =================== Project 1 I/O requirement ===========

Project 1 ªºI/O­n¨D

§A­n¼gªº¬O¤@­Óinteractive system¡C¦pªG¥¿±`(¦bDOSµøµ¡)¶]¡A¨ä¹B§@¸òPetite 
Chez Schemeªº¹B§@«Ü¹³¡C¨ä¨Ò¦p¤U(note that for the first project, you only
need to read in an S-expression and then print out an S-expression)¡G

  Welcome to OurScheme!
  
  > a   ; a line-comment starts with a ';', and continues until end-of-line
  a
  
  > 3   ; your system should be able to skip all line-comments
  3
  
  > (cons 3 5)  ; once it prints the output, it prints a blank line
  ( cons
    3
    5
  )
  
  >             ; the system first prints '> ', and then starts to get
                ; the user's input until either an unexpected character
     (    (     ; is encountered or the user has entered an S-expression
                ;
  Hi "!" How    ; note that the principle of "longest match preferred" 
                ; should be honored ; e.g., if the user enters 'How', 
  . "are you?"  ; you should get 'How' and not (just) 'H' or 'Ho' ;
  
        )   "Fine.  Thank you."
        
   )    ( 3 .   ; if, on the same line that the S-expression ends, the
  ( ( Hi
      "!"
      How
      .
      "are you?"
    )
    "Fine.  Thank you."
  )
  
  >             ; user also starts another input, then the
                ; system also starts processing the second input,
         .      ; but will print the output for the first input first
  ERROR (unexpected character) : line 4 column 8 character '.'
  
  > ( 1 2 ) ( 3 4 ) 5
  ( 1
    2
  )
  
  > ( 3
    4
  )
  
  > 5
  
  > ; the above is an example of how the system handles "multiple
    ; input on the same line"
    ; The point : the user may have already started entering input
    ;             BEFORE the system prints '> '
    
    (exit     ; this is the way to get out of user-system dialog ;
              ; below, there is a LINE-ENTER preceding 'Thanks' and
   )          ; two LINE-ENTER following '!'
  
  Thanks for using OurScheme!

// ===================================================

¦ýPAL¬O¥Î¤@­ÓinputÀÉ¨Ó´ú§Aªº¨t²Î¡A¦Ó¥B§Aªºµ{¦¡ªºoutput·|"¾É"¨ì
¤@­ÓoutputÀÉ¥h¡C©Ò¥H¡A·íPAL´ú¸Õ§Aªºµ{¦¡®É¡Ahere is what really 
happens :

// input¦Û¤U¤@¦æ¶}©l
1
a   ; a line-comment starts with a ';', and continues until end-of-line
3   ; your system should be able to skip all line-comments
(cons 3 5)  ; once it prints the output, it prints a blank line
            ; the system first prints '> ', and then starts to get
              ; the user's input until either an unexpected character
   (    (     ; is encountered or the user has entered an S-expression
              ;
Hi "!" How    ; note that the principle of "longest match preferred" 
              ; should be honored ; e.g., if the user enters 'How', 
. "are you?"  ; you should get 'How' and not (just) 'H' or 'Ho' ;

      )   "Fine.  Thank you."
      
 )    ( 3 .   ; if, on the same line that the S-expression ends, the
            ; user also starts another input, then the
              ; system also starts processing the second input,
       .      ; but will print the output for the first input first
( 1 2 ) ( 3 4 ) 5
; the above is an example of how the system handles "multiple
  ; input on the same line"
  ; The point : the user may have already started entering input
  ;             BEFORE the system prints '> '
  
  (exit     ; this is the way to get out of user-system dialog ;
            ; below, there is a LINE-ENTER preceding 'Thanks' and
 )          ; two LINE-ENTER following '!'
// input¦Ü¤W¤@¦æ¤î



// output¦Û¤U¤@¦æ¶}©l
Welcome to OurScheme!

> a

> 3

> ( cons
  3
  5
)

> ( ( Hi
    "!"
    How
    .
    "are you?"
  )
  "Fine.  Thank you."
)

> ERROR (unexpected character) : line 4 column 8 character '.'

> ( 1
  2
)

> ( 3
  4
)

> 5

> 
Thanks for using OurScheme!
// output¦Ü¤W¤@¦æ¤î¡A¦Ó¥B¤£¥]¬A¤W¤@¦æªºtrailing white space(s)

µù¡G
  For some unknown reason, PAL cannot get the "final white spaces" in your
  output.
  
  Therefore, in the "standard answer" that PAL uses to compare your output
  with, there are no "final white spaces" either.

// ===================================================

PALªº¹B§@¬O³o¼Ë¡G

  ¥¦¥ýcompile§Aªºµ{¦¡¡A¦pªGcompile¨S°ÝÃD¡A¥¦´N¥Î­Y¤z´ú¸ÕÀÉ¨Ó´ú¸Õ§Aªºµ{¦¡¡C
  
  ¥¦¥ý´ú²Ä¤@­Ó´ú¸Õ¼Æ¾Ú¡A¤]´N¬Orun§Aªºµ{¦¡¡B¨Ã¥H²Ä¤@­Ó´ú¸ÕÀÉ§@¬°input¡B¦P®É¤]
  
  §â§Aªºµ{¦¡ªºoutput"¾É"¨ì¤@­ÓoutputÀÉ¡C
  
  ­Y§Aªºµ{¦¡¶¶§Qrun§¹(¯¬ºÖ§A¡I)¡APAL´N¤ñ¹ï§AªºoutputÀÉ»P¡u¼Ð·Çµª®×ÀÉ¡v¡A
  
  ­Y¤GªÌªº¤º®e¦³¥ô¦ó¤@ÂI¤£¦P¡APAL´N¨ì¦¹¬°¤î¡A¨Ã»¡"§Aµª¿ù¤F"(µ¹¬Ý¤£µ¹¬Ý«hºÝµø
  
  ³o¬O²Ä´X­Ó´ú¸Õ¼Æ¾Ú)¡C
  
  ­Y¤GªÌªº¤º®e§¹¥þ¬Û¦P¡APAL´N¥Î¤U¤@­Ó´ú¸ÕÀÉ¦A¨Ó¤@¦¸(¦pªG¤w¸g¨S¦³´ú¸ÕÀÉ¤F´N
  
  "®¥³ßµª¹ï")¡C
  
  ´«¥y¸Ü»¡¡A¦³´X­Ó´ú¸ÕÀÉ¡BPAL´N·|run§Aªºµ{¦¡´X¦¸(¦pªG§A³£¹Lªº¸Ü)¡C
  
  ¦pªG¦brun§Aªºµ{¦¡ªº(³o»ò¦h¦¸ªº)¹Lµ{¤§¤¤¦³"ºÃ¦üµL½a°j°é"©Îµo¥Íexception¡A
  
  PAL´N¨ì¦¹¬°¤î¡A¨Ã³qª¾§A¡C

// ===================================================

gTestNum ( ©Î uTestNum ) :

  ¬°¤FÀ°§U§Adebug¡A©Ò¦³ªº´ú¸Õ¼Æ¾Úªº¤@¶}©l³£¦³­Óinteger (it has no preceding
  
  white-spaces, and is immediately followed by a LINE-ENTER character)¡A
  
  ¦¹integer¥NªíµÛ"¥Ø«e³o­Ó´ú¸Õ¼Æ¾Ú¬O²Ä´X­Ó´ú¸Õ¼Æ¾Ú"¡C§AÀ³¸Ó¥Î¤@­Óglobal©Î
  
  file-scopeªºÅÜ¼Æ¨Ó¦s³o­Óinteger¡C¦¹integer¹ï©ó§Aªºdebug¤u§@±N·|«Ü¦³À°§U¡C
  
  (µ{¦¡¤@¶}©l´NÅª¥¦(¦¹test number«OÃÒ¦s¦b)¡AµM«á·Q¿ìªk(if you want)"¸õ¹L"
  
   ¨ä«áªºLINE-ENTER¡A¦A¶}©l§Aªº¥ô¦ó"¥¿±`processing"¡C)

// ===================================================

OurSchemeªºI/O³W¯x¡G

  ¡° °ò¥»ªºI/O³W¯x½Ð¥Ñ¥H¤WªºI/O½d¨Ò±À¾É
  
  ¡° °ò¥»¤W¡A(syntax) errorªºµo¥Í¡B¦b©ó(OurScheme)¨t²ÎÅª¨ì"¤£¸Ó¥X²{ªº¦r¤¸"¡A
     
     ·í³oª¬ªpµo¥Í®É¡A(OurScheme)¨t²ÎÀ³¸Óª¾¹D¦¹¦r¤¸ªºline»Pcolumn¡A
     
     ±q¦Ó¦L¥X¦p½d¨Ò¤¤©Ò¥Üªº
  
       ERROR (unexpected character) : line 4 column 8 character '.'  

     ¦ý¦³¤@­Óª¬ªp¤ñ¸û¯S®í(¨Æ¹ê¤W¦³¦hºØ¡A§Ú­Ì¥u¦Ò¼{³oºØ)¡A¨º´N¬Ostring
     
     ÁÙ¨S"close"´N¤w¥X²{LINE-ENTER¡C¨Ò¡G // °²³]'('¬Ocolumn 1
                                         // ²Ä¤@¦æ¦@18¦r¤¸(¤£­pLINE-ENTER)
             ( cons "Hi" "How  
                   are you" )
     
     ¦¹®É­n¦Lªº¬O
     
       ERROR (unexpected character) : line 1 column 19 LINE-ENTER encountered

  ¡° ¤@¥¹µo¥Íunexpected character¿ù»~¡A¸Ó¦æ´N§¹¥þskip¡A
  
     ¨t²Î·|§â¨Ï¥ÎªÌªº¤U¤@¦æµø¬°(¨t²Î¦L¥X)'> '¤§«áªºinput¡C

  ¡° ¦LS-expressionªº³W¯x¦C©ó¥»¤å³Ì«á¡C

  ¡° ¤@¥¹¤wprocess¨ì¨Ï¥ÎªÌ©Òenterªº'(exit)'¡A¤§«á¦binputÀÉ¤¤­YÁÙ¦³¥ô¦ó
     
     ¨Ï¥ÎªÌinput¡A¨t²Î³£¤£¶·¤]¤£¸Ó²z·|¡C

  ¡° ¥Ñ©ó¬O¥ÎinputÀÉµ¹input¡B¦Ó¤£¬Ointeractive I/O¡A©Ò¥H¦³¥i¯àµo¥Í¡u¨Ï¥ÎªÌ
  
     ÁÙ¨Sinput§¹¤@­ÓS-expression´N¨Sinput¤F¡vªºª¬ªp¡A
     
     ¦¹®É¨t²ÎÀ³¸Ó­nprint¦p¤Uªºmessage :
     
       ERROR : END-OF-FILE encountered when there should be more input
       
       Thanks for using OurScheme!
       
// ===================================================

Rules for printing an S-expression s

if s is an atom
  then print s with no leading white space and with one trailing '\n'
       note : For 'nil', '()' and '#f', always print 'nil'.
       note : For '#t' and 't', always print '#t'.
       
else { // s is of the form : '(' s1 s2 ... sn [ '.' snn ] ')'

  let M be the number of characters that are already 
      printed on the current line
      
  print '(', print one space, print s1
  print M+2 spaces, print s2
  ...
  print M+2 spaces, print sn
  if there are '.' and snn following sn
    print M+2 spaces, print '.', print '\n'
    print M+2 spaces, print snn
  print M spaces, print ')', print '\n'
  
} // else s is of the form : '(' s1 s2 ... sn [ '.' snn ] ')'


Example : 

  (((1 . 2) (3 4) 5 . 6) 7 . 8)
  
  should be printed as // output¤§¤¤ªº¦U¦æªº«e¨â­Óspace¤£ºâ
  
  // output starts from the next line
  ( ( ( 1
        .
        2
      )
      ( 3
        4
      )
      5
      .
      6
    )
    7
    .
    8
  )
  // output terminates here, and does not include this line
  // all lines in the output have no trailing spaces or tabs

Example : 

  (((1 . "ICE CYCU") (THIS is (41 42 . 43)) Chung . Yuan) 7 . 8)
  
  should be printed as // output¤§¤¤ªº¦U¦æªº«e¨â­Óspace¤£ºâ
  
  // output starts from the next line
  ( ( ( 1
        .
        "ICE CYCU"
      )
      ( THIS
        is
        ( 41
          42
          .
          43
        )
      )
      Chung
      .
      Yuan
    )
    7
    .
    8
  )
  // output terminates here, and does not include this line
  // all lines in the output have no trailing spaces or tabs




// =================== Q and A No. 1 =======================

Question : '(1 2 3)ªºoutputÀ³¸Ó¬O¤°»ò¡H

Answer :

Project 1 :

> '(1 2 3)
( quote
  ( 1
    2
    3
  )
)


Project 2 :

> '(1 2 3)
( 1
  2
  3
)

¸ÑÄÀ¡G

Project 1¥uÅª¶i¨Ó(«Ø¥XDS)¡B¤£evaluate´Nª½±µ(§âDS)¦L¥X¥h¡A
©Ò¥H±o : (quote (1 2 3))¡C

Project 2¬OÅª¶i¨Ó(«Ø¥XDS)¡Bevaluate(¦¹DS)¡B¦A§âevaluateªºresult
(¨ÌÂÂ¬O­ÓDS)¦L¥X¥h¡A©Ò¥H±o : (1 2 3)¡C

(±N'(quote (1 2 3))'¤©¥Hevaluate©Ò±oªºµ²ªG¬O'(1 2 3)')



// =================== Q and A No. 2 =======================

¡° ¤Þ­z¡m...¡n¤§»Ê¨¥¡G

> ½Ð°Ý¦Ñ¤j~~

> 1.·í¿é¤J'> .'®É¡A·|¬OERROR¶Ü???
>   ­Y¬O¬OERROR.msg¡G·|¬Ocolumn: 1 or 2 ???

   It is an error.  (Let us suppose that it is '> .$', where '$' is
   LINE-ENTER char.)

   column : 2   '.' is the very first user input char
                on this line.  (the space before it is system output)

   Why column 2 and not column 1? Please see my answer to your second

   question below. (The system detects an error when it sees the LINE-

   ENTER char.)

> 2.¦b´ú¸Õ¼Æ¾Ú¤¤¦³¿é¤J(12.5)(12(. 3))

> µª®×¬O:

> > ( 12.500
> )
> > ERROR (unexpected character) : line 1 column 6 character ' '

> ¦ý¬O¦bOurScheme¤¤

> > (12 (    . 3))
> ERROR (unexpected character) : line 1 column 10 character '.'

> ¤§«eªºinput¬O'.'¿ù¡A²{¦bªºinput«h¬O' '¿ù¡A¬°¤°»ò©O???

In the case of (the first one) '(12(. 3))', everything is still

OK when the system (i.e., your system) "sees" '.'.  Why?  Because '.'

may be followed by a digit such as '5'.  The system detects an error

only when it sees that there is a space following '.'.  Therefore, the

"error char" (the char that caused the error) is the space and not the '.'


In the case of (the second one) '(12 (    . 3))', the error char should

also be the space-char following that '.'   You just found an error in my

Project 1 handout.  Thank you.  (And I have taken the liberty to

correct this error in both OurSchemeProj1.txt and HowToWriteOurScheme.doc)


> 3.½Ð°Ýabc"abc·|¦L¥X¤°»ò©O???

  The first token is 'abc'. The second token is a string that starts

  with : "abc

  e.g., // for project 1

  > abc"abc   "
  abc

  > "abc   "

¡÷ yabuki ±À¡G¦Ñ¤j¨ºabc'abcºâ¬Osymbol¶Ü?ÁÙ¬O·|¦³¨ä¥Lµ²ªG?        03/09 22:27
¡÷ hsia ±À¡Gthe case of abc'abc similar to the above case,       03/10 08:57
¡÷ hsia ±À¡Gbecause single-quote, double-quote R separators      03/10 08:58



// =================== Q and A No. 3 =======================

¡° ¤Þ­z¡m...¡n¤§»Ê¨¥¡G

> ³o°ÝÃD§xÂZ«Ü¤[¦Ê«ä¤£±o¨ä¸Ñ¡C

>
> ¨ÌÃD·NÀ³¸Ó¬O³Ì«á¤@­Ó¥i¥H°õ¦æ¡]©Î¦L¥X¡^ªºToken«á±N¦æ¸¹©MÄæ¦ìªì©l¤Æ
> ½d¨Ò¦p¤U

> ()   )
>  ^³oª±·N¨à¬O³Ì«áªºtoken¡A©Ò¥H­n¦L¥X¦bline 1¿ù

> °ÝÃD¨Ó¤F¡G
> "³Ì«á¤@­Ó¦r¦ê"\n
> \n
>   \n
> "¥X¿ùÂI

> ¬°¤°»ò³o¸Ì¦Lline 3¡H§â³Ì«á¤@­Ó¦r¦êtoken®³±¼«áÀ³¸Ó¦p¤U
> \n¡@¡@¡@¡@¡@¡@¡@¡@¡@¡@¡@¡@¡@¡@¢°
> \n                            ¢±
>   \n                          ¢²
> "¥X¿ùÂI                     ²Ä¢³¦æ
> ---------------

> "³Ì«á¤@­Ó¦r¦ê"¡@¡@¡@¡@¡@¡@\n¡@¢°
> \n                            ¢±
>   \n                          ¢²
> "¥X¿ùÂI                       ¢³

> ¥[¤FªÅ¥Õ¬°¤°»ò¤]¬Oline 3¡H

³o¨S¤°»ò¦n¦Ê«ä¤£±o¨ä¸Ñªº¡C ³o¬O³W¹º®Éªº«äºü¤£°÷²Ó±K¡C

ªº½T¡AÄY®æ¨ÓÁ¿¡B«ö·Ó³W©w¡B³Ì«á¤@­ÓcaseªºerrorÀ³¬O²Ä¥|¦æ¡B¦Ó«D²Ä¤T¦æ¡C

·íªì³W¹º®É¥¼¦Ò¼{¨ì¡u¦blegal input¤§«á­YÁÙ¦³(¤]¥u¦³)space«ç»òºâ¤U¤@inputªº¦æ¼Æ¡v

ªº°ÝÃD¡C

¤£¹L¡A§A´N·í³ocase¬O¡ugeneral³W©w¡vªºexception§a¡A·N§Y¡G



  ¦blegal input¤§«á(¦P¤@¦æ)­n¥X²{¡u¤U¤@­Óinput S-expressionªº¦³®Ä¦r¤¸¡v¡A
  ¤~§â³o¤@¦æºâ§@¬O¤U¤@inputªº²Ä¤@¦æ¡C  ­Ylegal input¤§«á(¦P¤@¦æ)¥u¥X²{
 ¡uspace©Îtab©Îµù¸Ñ¡v¡A¨º³o¤@¦æ´N¤£ºâ§@¬O¤U¤@inputªº²Ä¤@¦æ¡C



¡° ¤Þ­z¡m...¡n¤§»Ê¨¥¡G
> ½Ð°Ý¤@¤UPALªºproj2¼Æ¾Ú¡A·í«ü¥O¬°(exit)®É¡Aoutput¬°
> 
> Thanks for using OurScheme!

> ¬°¤°»ò¤£¬O
> Thanks for using OurScheme!

> ¬O¤£¬O­nprint "\nThanks for using OurScheme!"
> ÁÂÁÂ

µª®×¬O¡G

  Project­n¨D

  > (     ;; user input, with an ENTER at the end
          ;; user input, with an ENTER at the end
    exit  ;; user input, with an ENTER at the end
          ;; user input, with an ENTER at the end
       )  ;; user input, with an ENTER at the end

  Thanks for using OurScheme!;; system output













