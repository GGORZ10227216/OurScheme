1
(define a "=============== Problem 4 viewable case =================")
a
( clean-environment )

; Expert System Shell + Condition-BST & Action-BST - complex

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Utilities ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Petite-Scheme (SWL) will also need the following 
;
; ( define ( create-error-object str )
;   str
; ); define create-error-object
; 
; ( define ( error-object? obj )
;   ( string? obj )
; ); define error-object?
; 
; unfortunately, the problem of 'nil' cannot be solved straightforwardly
; sometimes it needs to be changed to '() (in the case of lists)
; sometimes it needs to be changed to #f  (in the case of booleans)
;
; ( define nil '() )
;
; for most cases, the above definition of 'nil' will do (since it just changes >>nil<< to >>'()<<)
; in few cases, we have to manually change >>nil<< to >>#f<<
; 
; ( define ( verbose? )
;   #t
; );define verbose?
;
; ( define ( verbose setting )
;   #t
; );define verbose

; car               ; first one
 
( define ( cadr x ) ; second one

  ( car ( cdr x ) )
  
);define cadr

( define ( caddr x ) ; third one

  ( car ( cdr ( cdr x ) ) )
   
);define caddr

( define ( caar x ) ; 'car' of first one

  ( car ( car x ) )
  
);define caar

( define ( caadr x ) ; 'car' of second one

  ( car ( cadr x ) )
  
);define caar

( define ( caaddr x ) ; 'car' of third one

  ( car ( caddr x ) )
   
);define caaddr

;=========================== Utilities ===============================

; Skip the following definition of '%' when running Petite-Scheme (SWL).
; ( we use the next definition of '%' instead !!! )

( define ( % original divider )

  ( cond ( ( not ( integer? original ) )
           ( create-error-object ( string-append "% : " ( number->string original )
                                                 " is not an integer."
                                 )
           )
         )
         ( ( not ( integer? divider ) )
           ( create-error-object ( string-append "% : " ( number->string divider )
                                                 " is not an integer."
                                 )
           )
         )
         ( else
           ( - original ( * ( / original divider )
                            divider
                        )
           )
         );else
         
  );cond
  
);define %

; Use the following definition of '%' when running Petite-Scheme (SWL)
;
; ( define ( % original divider )
;   ( modulo original divider )
; );define %

;=========================== Utilities ===============================

( define $%%% 379 )

( define ( KeyPair original )
  
  ( if ( < original $%%% )
    ( create-error-object ( string-append "Please use a number greater than "
                                          ( number->string $%%% )
                                          " as key."
                          )
    )
    ( cons ( % original $%%% )
           ( list original )
    )
  );if
  
);define KeyPair

( define ( RealKey original )

; the "key" defined by KeyPair() from 'original'
  
  ( if ( < original $%%% )
    
    original
    
    ( % original $%%% )

  );if
  
);define RealKey

;=========================== Utilities ===============================

( define ( ListAppend firstList secondList )

  ( cond ( ( and ( atom? firstList )
                 ( not ( null? firstList ) )
           )
           ( create-error-object "( ListAppend firstList secondList ) : First one must be a list." )
         )
         ( ( and ( atom? secondList )
                 ( not ( null? secondList ) )
           )
           ( create-error-object "( ListAppend firstList secondList ) : Second one must be a list." )
         )
    ( else 
      ( $ListAppend firstList secondList )
    )
    
  );cond
  
);define ListAppend

( define ( $ListAppend firstList secondList )
; prerequisite: both 'firstList' and 'secondList' are lists (including the case of '())

  ( if ( null? firstList )
  
      secondList
      
      ( cons ( car firstList )
             ( $ListAppend ( cdr firstList )
                           secondList
             )
      );cons
      
  );if

);define ListAppend

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( ListLength s-expr )

  ( cond 
  
    ( ( null? s-expr ) 0 )
    
    ( ( atom? s-expr ) ( create-error-object "( ListLength s-expr ) : s-expr is a non-nil atom" )
    )
    
    ( else ( $ListLength s-expr )
    )
    
  );cond
  
);define ListLength
                           
( define ( $ListLength aList )

; prerequisite: aList is either a non-empty list (i.e., it must not be '()) 
;                        or a dotted pair

  ( let ( ( remaining ( cdr aList ) )
        );local 
        
    ( if ( atom? remaining ) ; either '() or a real atom, which means that aList is not really a list
    
         1
         
         ( + 1 ( $ListLength remaining ) 
         )
         
    );if
    
  );let
  
);define $ListLength
                           
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( NthElementOf n s-expr )

  ( cond
  
    ( ( not ( integer? n ) ) 
      ( create-error-object "( NthElementOf n s-expr ) : Illegal first argument!" )
    )
    
    ( ( < n 1 )
      ( create-error-object "( NthElementOf n s-expr ) : Illegal first argument!" )
    )
    
    ; assert : n is a natural number
    
    ( ( null? s-expr )
      ( create-error-object "( NthElementOf n s-expr ) : Illegal second argument!" )
    )
    
    ( ( atom? s-expr )
      ( create-error-object "( NthElementOf n s-expr ) : Illegal second argument!" )
    )
    
    ; assert : s-expr is a dotted pair
    
    ( else
      ( $NthElementOf n s-expr )
    )
    
  );cond
  
);define NthElementOf

( define ( $NthElementOf n s-expr )
; prerequisite: n is a natural number and s-expr is a dotted pair (i.e., if list then non-empty)

  ( if ( = n 1 )
  
     ( car s-expr )
     
     ; n > 1
     
     ( let ( ( rest ( cdr s-expr ) )
           );local
           
        ( if ( atom? rest ) ; i.e., no more!
        
            ( create-error-object "( NthElementOf n s-expr ) : Value of n exceeds length of the given s-expression." )
            
            ( $NthElementOf ( - n 1 ) rest )
            
        );if
        
     );let
     
  );if
  
);define $NthElementOf

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( WithNthElementOfListReplaced n aList newElement )

; given 4 and ( a b c d e f g ) and XYZ
; it means: replace the 4TH of ( a b c d e f g ) with XYZ
; result : ( a b c XYZ e f g)

  ( cond ( ( not ( integer? n ) )
           ( create-error-object "( WithNthElementOfListReplaced n aList newElement ) : n is not an integer" )
         )
         ( ( < n 1 ) 
           ( create-error-object "( WithNthElementOfListReplaced n aList newElement ) : n is not a natural number" )
         )
         ( ( < ( ListLength aList ) n )
           ( create-error-object "( WithNthElementOfListReplaced n aList newElement ) : value of n exceeds length of aList" )
         )
         ( else
           ( $WithNthElementOfListReplaced n aList newElement )
         )
  );cond
  
);define WithNthElementOfListReplaced
  
( define ( $WithNthElementOfListReplaced n aList newElement )

; given 4 and ( a b c d e f g ) and XYZ
; it means: replace the 4TH of ( a b c d e f g ) with XYZ
; result : ( a b c XYZ e f g)

  ( if ( = n 1 ) ; we are to replace the first one of 'aList'
  
       ( cons newElement
              ( cdr aList )
       )
       
       ; n > 1
       
       ( let ( ( first ( car aList ) )
               ( new-rest ( $WithNthElementOfListReplaced ( - n 1 ) ( cdr aList ) newElement
                          )
               )
             )
         ( cons first new-rest )
       );let
       
  );if
  
);define $WithNthElementOfListReplaced
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; ( define ( DivisibleBy n factor )
; 
;   ( = n 
;       ( * ( / n factor ) factor )
;   )
;    
; );define DivisibleBy

( define ( DivisibleBy n factor )
  
  ( = ( % n factor )
      0
  )

);define DivisibleBy

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( PrintListOfStringsAsSentence aList )

  ( if ( not ( null? aList ) )
     ( begin
     
       ( display-string ( car aList ) ) 
       ; instead of : 
       ; ( display-string ( eval ( car aList ) ) )
       
       ( display-string " " )
       ( PrintListOfStringsAsSentence ( cdr aList ) )
     )
     ( begin
       ( newline )
       #t
     )
  );if
  
);define PrintListOfStringsAsSentence
     
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( PrintListOfSymbolsAsSentence aList )
; with a LINE-ENTER at the end

  ( if ( not ( null? aList ) )
     ( begin
       ( display-string ( symbol->string ( car aList ) ) )
       ( display-string " " )
       ( PrintListOfSymbolsAsSentence ( cdr aList ) )
     )
     ( begin
       ( newline )
       #t
     )
  );if
  
);define PrintListOfSymbolsAsSentence
     
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( PrintListOfSymbolsStringsAsSentence aList )

  ( if ( not ( null? aList ) )
     ( begin
       ( display-string ( let ( ( element ( car aList ) )
                              );local
                          ( if ( symbol? element )
                               ( symbol->string ( car aList ) ) 
                               element
                          )
                        );let
       )
       ( display-string " " )
       ( PrintListOfSymbolsStringsAsSentence ( cdr aList ) )
     )
     ( begin
       ( newline )
       #t
     )
  );if
  
);define PrintListOfSymbolsStringsAsSentence
     
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( PrintListOfSymbolsNumbersStringsAsSentence aList )

  ( if ( not ( null? aList ) )
     ( begin
       ( display-string ( let ( ( %element ( car aList ) )
                              );local
                          ( cond ( ( symbol? %element )
                                   ( symbol->string %element )
                                 )
                                 ( ( number? %element )
                                   ( number->string %element )
                                 )
                                 ( else 
                                   %element
                                 )
                          )
                        );let
       )
       ( display-string " " )
       ( PrintListOfSymbolsNumbersStringsAsSentence ( cdr aList ) )
     )
     ( begin
       ( newline )
       #t
     )
  );if
  
);define PrintListOfSymbolsNumbersStringsAsSentence
     
;=========================== Utilities ===============================

;=========================== Expert system shell ===============================

( define @size@ 3 )    ;   5 : 'HUGE        'LARGE   'MEDIUM    'SMALL    1 : 'TINY
( define @price@ 3 )   ;   5 : 'EXPENSIVE   'HIGH    'AVERAGE   'LOW      1 : 'VERY-AFFORDABLE 
( define @quality@ 3 ) ;   5 : 'EXCELLENT   'GOOD    'AVERAGE   'BAD      1 : 'TERRIBLE

( define ( ResetTransactionState )

  ( set! @quality@ 3 )
  ( set! @price@ 3 )
  ( set! @size@ 3 )
  #t
  
);define ResetTransactionState

( define ( ProductIndex )
  ( cond ( ( = @quality@ 5 )
           ( + ( - 18 @price@ ) @size@ 3 )                ; max : 25
         )
         ( ( = @quality@ 4 )
           ( + ( - 15 @price@ ) @size@ )                  ; ref. point : 15
         )
         ( ( = @quality@ 3 )
           ( + @price@ @size@ )                           ; average : 6
         )
         ( ( = @quality@ 2 )
           ( - @size@ ( + 4 @price@ ) )                   ; ref. point : -4
         )
         ( ( = @quality@ 1 )
           ( - @size@ ( + 8 @price@ ) )                   ; min : -12
         )
         ( else
           ( create-error-object ( string-append "Invalid @quality@ value : " ( number->string @quality@ )
                                 )
           )
         )
  );cond

);define ProductIndex

( define ( TransactionState )

  ( string-append "quality : " ( number->string @quality@ )
                  " size : "   ( number->string @size@ )
                  " price : "  ( number->string @price@ )
                  " ProductIndex : " ( number->string ( ProductIndex ) )
  )
  
);define TransactionState

( define ( Top? n )
  ( = n 5 )
);define Top?

( define ( Bottom? n )
  ( = n 1 )
);define Bottom?

( define ( TopPrice? )
  ( Top? @price@ )
);define TopPrice?

( define ( BottomPrice? )
  ( Bottom? @price@ )
);define BottomPrice?

( define ( TopSize? )
  ( Top? @size@ )
);define TopSize?

( define ( BottomSize? )
  ( Bottom? @size@ )
);define BottomSize?

( define ( TopQuality? )
  ( Top? @quality@ )
);define TopQuality?

( define ( BottomQuality? )
  ( Bottom? @quality@ )
);define BottomQuality?

( define ( Downgrade n )
  ( if ( = n 1 )
    1
    ( - n 1 )
  )
);define Downgrade

( define ( Upgrade n )
  ( if ( = n 5 )
    5
    ( + n 1 )
  )
);define Downgrade

( define ( DowngradeSize )
  ( set! @size@ ( Downgrade @size@ ) )
);define DowngradeSize

( define ( DowngradePrice )
  ( set! @price@ ( Downgrade @price@ ) )
);define DowngradePrice

( define ( DowngradeQuality )
  ( set! @quality@ ( Downgrade @quality@ ) )
);define DowngradeQuality

( define ( UpgradeSize )
  ( set! @size@ ( Upgrade @size@ ) )
);define UpgradeSize

( define ( UpgradePrice )
  ( set! @price@ ( Upgrade @price@ ) )
);define UpgradePrice

( define ( UpgradeQuality )
  ( set! @quality@ ( Upgrade @quality@ ) )
);define UpgradeQuality

( define ( Abs n )

  ( if ( > n 0 )
    n
    ( * -1 n )
  )
  
);define Abs

( define ( PriceTag income )

  ( let ( ( %type ( % income 3 ) )
        );local

    ( cond
      ( ( = %type 0 ) ; over
      
        ( let ( ( %p ( ProductIndex )
                )
              );local
              
          ( cond 
            ( ( > %p 15 )
              ( + ( * 22000 %p )
                  ( * income 0.4 )
              )
            )
            ( ( > %p 5 )
              ( + ( * 21000 %p )
                  ( * income 0.3 )
              )
            )
            ( ( > %p -5 )
              ( cond ( ( > %p 0 )
                       ( + ( * 20000 %p )
                           ( * income 0.2 )
                       )
                     )
                     ( ( = %p 0 )
                       ( + 19000 ( * income 0.2 ) )
                     )
                     ( else ; %p < 0
                       ( + 19000 ( * %p 500 ) ( * income 0.2 ) )
                     )
              )
            )
            ( ( > %p -13 )
              ( + 19000 ( * %p 600 ) ( * income 0.1 ) )
            )
            ; no ELSE to force error msg.
          );cond
          
        );let %p
        
      ) ; type 0
      
      ( ( = %type 1 ) ; fair
      
        ( let ( ( %p ( ProductIndex )
                )
              );local
              
          ( cond 
            ( ( > %p 15 )
              ( + ( * 20000 %p )
                  ( * income 0.3 )
              )
            )
            ( ( > %p 5 )
              ( + ( * 20000 %p )
                  ( * income 0.2 )
              )
            )
            ( ( > %p -5 )
              ( cond ( ( > %p 0 )
                       ( + ( * 20000 %p )
                           ( * income 0.1 )
                       )
                     )
                     ( ( = %p 0 )
                       ( + 18000 ( * income 0.1 ) )
                     )
                     ( else ; %p < 0
                       ( + 18000 ( * %p 800 ) ( * income 0.1 ) )
                     )
              )
            )
            ( ( > %p -13 )
              ( + 18000 ( * %p 1000 ) ( * income 0.1 ) )
            )
            ; no ELSE to force error msg.
          );cond
          
        );let %p
        
      ) ; type 1
      
      ( ( = %type 2 ) ; low
      
        ( let ( ( %p ( ProductIndex )
                )
              );local
              
          ( cond 
            ( ( > %p 15 )
              ( + ( * 15000 %p )
                  ( * income 0.1 )
              )
            )
            ( ( > %p 5 )
              ( + ( * 15000 %p )
                  ( * income 0.1 )
              )
            )
            ( ( > %p -5 )
              ( cond ( ( > %p 0 )
                       ( + ( * 15000 %p )
                           ( * income 0.1 )
                       )
                     )
                     ( ( = %p 0 )
                       ( + 13000 ( * income 0.1 ) )
                     )
                     ( else ; %p < 0
                       ( + 13000 ( * %p 1000 ) ( * income 0.1 ) )
                     )
              )
            )
            ( ( > %p -13 )
              ( + 13000 ( * %p 1000 ) ( * income 0.1 ) )
            )
            ; no ELSE to force error msg.
          );cond
          
        );let %p
        
      ) ; %type 2
      
    );cond %type
    
  );let %type
    
);define PriceTag

; expertise df= name-0f-the-expertise
;               +
;               list of rules ( a rule-set, implicitly ordered )
;                 where
;                 a rule df= '(' <condition> <action> ')' // multiple actions allowed
;               +
;               a (evaluated) definition of some corresponding function (a function that can be called)

; For each expertise that exists (i.e., for each name-of-expertise that can be called)
; there is a corresponding entry in the expertise-DB ($expertise-DB).
; This entry df= '(' name-of-expertise <rule> { <rule> } ')'

; for example

( define ( ExampleExpertise n ) ; a function that can be called

  ; Just what is an experise?
  ; an expertise is (in here) an oredered list of rules ( of the form: <condition> -> <action> )

  ( cond
  
    ( ( DivisibleBy n 3 ) ; condition
    
      ( cond              ; action ; it can be multiple actions
      
        ( ( not ( TopSize? ) )
          ( UpgradeSize )
        )
        ( ( not ( TopPrice? ) )
          ( UpgradePrice )
        )
        ( ( not ( TopQuality? ) )
          ( UpgradeQuality )
        )
        
      );cond
      
      ( TransactionState )
      
    ); rule-01
    
    ( ( DivisibleBy n 5 ) ; condition
    
      ( cond              ; action ; it can be multiple actions
        ( ( not ( BottomSize? ) )
          ( DowngradeSize )
        )
        ( ( not ( BottomPrice? ) )
          ( DowngradePrice )
        )
        ( ( not ( BottomQuality? ) )
          ( DowngradeQuality )
        )
      );cond
      
      ( TransactionState )
      
    ); rule-02
    
    ( else                ; condition (which may or may not be 'else')
    
      ( if ( not ( TopPrice? ) ) ; action ; it can be multiple actions
           ( UpgradePrice )
      )
      
      ( TransactionState )
      
    ); rule-03
    
  );cond
  
);define ExampleExpertise

( define $expertise-DB 

  ; for simplicity, we do not sort this DB by expertise-names for the moment 
  ; (to do that, we will need to use a BST)

  '( ( ExampleExpertise ; name of the expertise ; note that this is a symbol, not a string
     
       ; the list of rules associated with >>ExampleExpertise<<
       
       ( ( DivisibleBy n 3 ) ; condition
       
         ( cond              ; action ; it can be multiple actions
         
           ( ( not ( TopSize? ) )
             ( UpgradeSize )
           )
           ( ( not ( TopPrice? ) )
             ( UpgradePrice )
           )
           ( ( not ( TopQuality? ) )
             ( UpgradeQuality )
           )
           
         );cond
         
         ( TransactionState )
         
       ); rule-01
       
       ( ( DivisibleBy n 5 ) ; condition
       
         ( cond              ; action ; it can be multiple actions
           ( ( not ( BottomSize? ) )
             ( DowngradeSize )
           )
           ( ( not ( BottomPrice? ) )
             ( DowngradePrice )
           )
           ( ( not ( BottomQuality? ) )
             ( DowngradeQuality )
           )
         );cond
         
         ( TransactionState )
         
       ); rule-02
       
       ( else                ; condition (which may or may not be 'else')
       
         ( if ( not ( TopPrice? ) ) ; action ; it can be multiple actions
              ( UpgradePrice )
         )
         
         ( TransactionState )
         
       ); rule-03
    
     );the expertise >>ExampleExpertise<<
     
   ) ; $expertise-DB
   
  ; for each expertise stored in $expertise-DB, 
  ; its CAR is name-of-the-expertise (a symbol), and its CDR is the list-of-rules associated with this "expertise",
  ; with each rule being of the form >>( <condition> <action> )<< ; note again, that multiple actions are allowed
   
);define $expertise-DB

( define ( RuleSetOf expertiseName )

  ( if ( null? $expertise-DB )
  
       ( create-error-object ( string-append ( symbol->string expertiseName ) " not found (expertise-DB is currently empty)" ) )  
         
       ( $RuleSetOfFrom expertiseName $expertise-DB )
  );if
  
);define RuleSetOf

( define ( $RuleSetOfFrom expertiseName list-of-expertise )

; >>expertiseName<< is a symbol
; >>list-of-expertise<< is the list to be searched for the expertise with name being expertiseName ;
; prerequisite: 'list-of-expertise' is a non-empty list

  ( cond
  
    ( ( = ( ListLength list-of-expertise ) 1 )
    
      ( if ( equal? ( car ( car list-of-expertise ) ) expertiseName )
           ( cdr ( car list-of-expertise ) )
           ( create-error-object ( string-append ( symbol->string expertiseName ) " not found in expertise-DB" ) )
      )
    )
    
    ; ListLength > 1
    
    ( else
    
      ( if ( equal? ( car ( car list-of-expertise ) ) expertiseName )
           ( cdr ( car list-of-expertise ) )
           ( $RuleSetOfFrom expertiseName ( cdr list-of-expertise ) )
      )
    )
    
  );cond

);define $RuleSetOfFrom

;;;;;;;;;;;;;;

( define ( WithNthRuleReplaced n ruleList withThisRule )

  ; should do parameter-checks first

  ; ( WithNthElementOfListReplaced n aList newElement )
  
  ( WithNthElementOfListReplaced n ruleList withThisRule )
  
);define WithNthRuleReplaced

( define ( Rule condition action-list )

  ( cons condition action-list )
  
);define Rule

( define ( DefineExpertise nameOfExpertise listOfRules )

  ( let ( ( %code
            ( list 'define
                   ( cons nameOfExpertise '( n ) )
                   ( cons 'cond listOfRules )
            )
          )
          ( %add-result nil )
          ( %current-verbose-mode nil )
        );local-var
        
    ( set! %add-result ( $AddToExpertiseDB nameOfExpertise ( cons nameOfExpertise listOfRules ) )
    )
    
    ( if ( error-object? %add-result )
      
      ( begin
      
        ( display-string %add-result )
        ( newline )
        
        #f
        
      );begin
      
      ; no error
      
      ( begin
        
        ( set! %current-verbose-mode ( verbose? ) )
        ( verbose #f ) ; to disable the eval msg : abc defined
        ( eval %code ) ; define the expertise
        ( verbose %current-verbose-mode )
    
        ( display-string
          ( string-append "The expertise '" 
                          ( symbol->string nameOfExpertise )
                          "' has been established.\n" 
          )
        )
    
        #t
        
      );begin
      
    );if error
    
  );let %code

);define DefineExpertise

( define ( $AddToExpertiseDB nameOfExpertise expertise )
  
  ( let ( ( %n ( $IndexOfExpertiseEntry nameOfExpertise 1 $expertise-DB ) )
        );local
        
    ( if ( < %n 1 ) ; no expertise with name being 'nameOfExpertise' in $expertise-DB 
    
      ; directly add the description of this expertise to DB
      ( begin ( set! $expertise-DB  
                     ( cons expertise $expertise-DB ) 
              )
              #t
      )
      
      ; %n >= 1 ; i.e., there is already an expertise with the given name
      
      ( create-error-object
        ( string-append 
          "Sorry. There is already an expertise named '" 
          ( symbol->string nameOfExpertise )
          "' in the expertise-DB." 
        )
      )
    
    );if ( < %n 1 ) ; i.e., if there is no expertise with such a name in DB
  
  );let %n

);define $AddToExpertiseDB

( define ( $IndexOfExpertiseEntry nameOfExpertise currentIndex list-of-expertise )

; anyone (with the sole exception of $IndexOfExpertiseEntry) who calls this function should pass 1 as 'currentIndex'
; return value of -1 means "not in the given list-of-expertise"
;
; terminology : the index of 'c' in '(a b c d)' is 3 (and not 2)

  ; assert : the index of first element (of list-of-expertise) in the ORIGINAL LIST is 'currentIndex'

  ( cond ( ( null? list-of-expertise ) 
           -1 
         )
  
         ( ( equal? ( car ( car list-of-expertise ) ) 
                    nameOfExpertise 
           )
           currentIndex
         )
         
         ( else ; 'nameOfExpertise' is not the first one of list-of-expertise
         
           ( $IndexOfExpertiseEntry nameOfExpertise 
                                    ( + 1 currentIndex ) 
                                    ( cdr list-of-expertise ) 
           )
           
         );else
         
  );cond

);define $IndexOfExpertiseEntry

( define ruleList-01

  ; '( ( ( DivisibleBy n 15 )
  ;      ( + n 150 )
  ;    )
  ;    ( ( DivisibleBy n 5 )
  ;      ( + n 50 )
  ;    )
  ;    ( ( DivisibleBy n 4 )
  ;      ( + n 40 )
  ;    )
  ;    ( else
  ;      ( + n n )
  ;    )
  ;  )
   
  '( ( ( DivisibleBy n 3 ) ; condition
     
       ( cond              ; action ; it can be multiple actions
       
         ( ( not ( TopSize? ) )
           ( UpgradeSize )
         )
         ( ( not ( TopPrice? ) )
           ( UpgradePrice )
         )
         ( ( not ( TopQuality? ) )
           ( UpgradeQuality )
         )
         
       );cond
       
       ( TransactionState )
       
     ); rule-01
     
     ( ( DivisibleBy n 5 ) ; condition
     
       ( cond              ; action ; it can be multiple actions
         ( ( not ( BottomSize? ) )
           ( DowngradeSize )
         )
         ( ( not ( BottomPrice? ) )
           ( DowngradePrice )
         )
         ( ( not ( BottomQuality? ) )
           ( DowngradeQuality )
         )
       );cond
       
       ( TransactionState )
       
     ); rule-02
     
     ( else                ; condition (which may or may not be 'else')
     
       ( if ( not ( TopPrice? ) ) ; action ; it can be multiple actions
            ( UpgradePrice )
       )
       
       ( TransactionState )
       
     ); rule-03
    
   ); rule-list
   
); define ruleList-01

( DefineExpertise 'Expertise-01 ruleList-01 )

( define rule-139

  ; '( ( Divisible n 3 )
  ;    ( + n 30 )
  ;  )
  
  '( ( DivisibleBy n 5 ) ; condition
   
     ( cond              ; action ; it can be multiple actions
       ( ( not ( BottomPrice? ) )
         ( DowngradePrice )
       )
       ( ( not ( TopSize? ) )
         ( UpgradeSize )
       )
       ( ( not ( BottomQuality? ) )
         ( DowngradeQuality )
       )
     );cond
     
     ( TransactionState )
     
   ); a single rule
  
   
); define rule-139

                                ; WithNthRuleReplaced n ruleList withThisRule
( DefineExpertise 'Expertise-02 ( WithNthRuleReplaced 1 ruleList-01 rule-139 )
)

( DefineExpertise 'Expertise-03 
                  ; WithNthRuleReplaced n ruleList withThisRule
                  ( WithNthRuleReplaced 2
                                        ruleList-01 
                                        ( Rule
                                          '( DivisibleBy n 7 )  ; condition
                                          '(                    ; action-list
                                             ( + n 70 )
                                           )
                                        ) 
                  )
)

( define ( ListExpertiseNames )

; print the list of expertise-names for all expertise stored in $expertise-DB

  ( let ( ( %length ( ListLength $expertise-DB ) )
        );local
        
    ( if ( < %length 1 )
    
         ( begin
           ( display-string "The expertise database is currently empty" )
           #t
         )
         
         ( $ListExpertiseNames $expertise-DB )
         
    );if %length < 1
    
  );let %length
    
);define ListExpertiseNames

( define ( $ListExpertiseNames expertise-DB )

; print the list of expertise in 'expertis-DB'
; prerequisite: length of 'expertise-DB' >= 1

  ( display-string ( symbol->string ( car ( car expertise-DB ) ) 
                   )
  )
  ( newline )
  
  ( let ( ( %remaining-expertise ( cdr expertise-DB ) )
        );local

    ( if ( null? %remaining-expertise )
         #t
         ( $ListExpertiseNames %remaining-expertise )
    );if
    
  );let %remaining-expertise

);define $ListExpertiseNames

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( GetNotYetUsedKeyFromUser db-name )

; return a user-input that is a usable new key

  ( let ( ( %bst ( cond
                   ( ( equal? db-name 'condition )
                     $condition-bst
                   )
                   ( ( equal? db-name 'action )
                     $action-bst
                   )
                   ( ( equal? db-name 'expertise )
                     $expertise-bst
                   )
                   ; no ELSE to force error msg.
                 )
          );%bst
          
          ( %user-input nil )
          
        );locals
        
    ( display-string "Key (at least 5 digits) associated with the to-be-defined-item > " )
    
    ( set! %user-input ( read ) )
    
       ; ( $KeyUsedInBST? %bst ( RealKey key ) ) ; returns #f or non-#f
       
    ( if ( $KeyUsedInBST? %bst ( RealKey %user-input ) )
    
         ( begin
           ( display-string "Sorry, this key is already in use. Please specify another one.\n" )
           ( GetNotYetUsedKeyFromUser db-name )
         )
         
         %user-input
         
    );if
    
  );let
  
);define GetNotYetUsedKeyFromUser
         
; ( AddToBST 'condition key condition )

( define ( DoDefineCondition )

  ( let ( ( %key nil )
          ( %condition nil )
        );locals
        
    ( set! %key ( GetNotYetUsedKeyFromUser 'condition ) )
    
    ( display-string "The condition to be added to the DB > " )
    
    ( set! %condition ( read ) )
    
    ; AddToBST() should produce no errors and return a string containing key-info
    
    ( display-string ( AddToBST 'condition %key %condition ) )
    
    ( newline )
    
    #t
    
  );let
          
);define DoDefineCondition

( define ( DoDefineAction )

  ( let ( ( %key nil )
          ( %action-list nil )
        );locals
        
    ( set! %key ( GetNotYetUsedKeyFromUser 'action ) )
    
    ( display-string "The action-list to be added to the DB > " )
    
    ( set! %action-list ( read ) )
    
    ; AddToBST() should produce no errors and return a string containing key-info
    
    ( display-string ( AddToBST 'action %key %action-list ) )
    
    ( newline )
    
    #t
    
  );let
          
);define DoDefineAction

( define ( GetNotYetUsedExpertiseNameFromUser )

; return a user-input that is a new name for a to-be-defined expertise

  ( let ( ( %user-input nil )
        );locals
        
    ( display-string "Name of the to-be-defined-expertise > " )
    
    ( set! %user-input ( read ) )
    
    ( if ( NameUsedInExpertiseDB? %user-input )
    
         ( begin
           ( display-string "Sorry, this name is already in use. Please specify another one.\n> " )
           ( GetNotYetUsedExpertiseNameFromUser )
         )
         
         %user-input
         
    );if
    
  );let
  
);define GetNotYetUsedExpertiseNameFromUser
         
( define ( NameUsedInExpertiseDB? name )

  ( $NameUsedInExpertiseDB? name $expertise-DB )
  
);define NameUsedInExpertiseDB?

( define ( $NameUsedInExpertiseDB? name expertise-list  )

; returns #f or #t

  ( if ( null? expertise-list )
  
    #f
    
    ; 'expertise-list' not empty
    
    ( if ( equal? name ( caar expertise-list ) )
             
         #t
         
         ( $NameUsedInExpertiseDB? name ( cdr expertise-list ) )
         
    );if

  );if 'expertise-list' is empty
      
);define $NameUsedInExpertiseDB?

( define ( DoDefineExpertiseFromDB )

  ( let ( ( %rule-set nil )
          ( %expertiseName nil )
        );locals
    
    ( set! %expertiseName ( GetNotYetUsedExpertiseNameFromUser ) )
    ( set! %rule-set ( GetRuleSetFromDB ) )
    
    ; ( DefineExpertise nameOfExpertise listOfRules )
    
    ( DefineExpertise %expertiseName %rule-set )
    
  );let
  
);define DoDefineExpertiseFromDB

( define ( DoReplaceRuleOfExpertiseWithNewlyComposedRuleUsingDB )

  ( let ( ( %nameOfExpertise nil )
          ( %whichRule nil )
          ( %condition nil )
          ( %action-list nil )
          ( %new-rule nil )
        );local
        
    ( display-string "Name of the expertise you want to replace its rule > " )
    ( set! %nameOfExpertise ( read ) )
    
    ( display-string "Ordering of the rule that is to be replaced - Please enter a number (e.g., 3) > " )
    ( set! %whichRule ( read ) )
    
    ( display-string "We now need to compose a new rule using existing DB entries.\n" )
    
    ( set! %condition ( GetConditionFromDB ) ) 
    ( set! %action-list ( GetActionListFromDB ) ) 
    
    ( set! %new-rule ( cons %condition %action-list )
    )
           
    ; ( $ReplaceRuleOfRuleSet nameOfExpertise whichRule rule )
    ( $ReplaceRuleOfRuleSet %nameOfExpertise %whichRule %new-rule )
    
  );let %nameOfExpertise, %whichRule, %condition, %action-list, %new-rule

);define DoReplaceRuleOfExpertiseWithNewlyComposedRuleUsingDB

( define ( GetRuleSetFromDB )

; return a rule-set
  
  ( let ( ( %user-input nil )
          ( %condition nil )
          ( %action-list nil )
          ( %remaining-rule-list nil )
        );locals
  
    ( display-string "Define a new rule from Condition/Action-list in DB? (Y/N) > " )
    ( set! %user-input ( read ) )
    
    ( if ( or ( equal? %user-input 'Y )
              ( equal? %user-input 'y )
         )
    
         ( begin 
         
           ( set! %condition ( GetConditionFromDB ) ) 
           ( set! %action-list ( GetActionListFromDB ) ) 
           
           ( set! %remaining-rule-list ( GetRuleSetFromDB ) )
           
           ( cons ( cons %condition %action-list ) 
                  %remaining-rule-list
           )
           
         );begin
         
         nil  ; the definition of rule-list ends here
         
    );if
  
  );let
  
);define GetRuleSetFromDB
    
( define ( GetConditionFromDB )

; return the condition obtained from DB

  ( let ( ( %key nil ) 
          ( %result nil )
        );locals
  
    ( display-string "Key of the condition > " )
      
    ( set! %key ( read ) )
      
    ( set! %result ( SearchBST 'condition %key ) )
    
    ( if ( null? %result )
         ( GetConditionFromDB )
         %result
    )
    
  );let
  
);define GetConditionFromDB

( define ( GetActionListFromDB )

; return the action-list obtained from DB

  ( let ( ( %key nil ) 
          ( %result nil )
        );locals
  
    ( display-string "Key of the action-list > " )
      
    ( set! %key ( read ) )
      
    ( set! %result ( SearchBST 'action %key ) )
    
    ( if ( null? %result )
         ( GetActionListFromDB )
         %result
    )
    
  );let
  
);define GetActionListFromDB

; ( SearchBST 'condition key )

( define ( DoSearchCondition )

  ( let ( ( %key nil ) 
          ( %result nil )
        );locals
  
    ( display-string "Key of the condition to be searched for > " )
      
    ( set! %key ( read ) )
      
    ( set! %result ( SearchBST 'condition %key ) )
    
    ( if %result
         ( begin ( write %result ) 
                 ( newline )
         )
         #f
    )
    
  );let
  
);define DoSearchCondition

( define ( DoSearchAction )

  ( let ( ( %key nil ) 
          ( %result nil )
        );locals
  
    ( display-string "Key of the action-list to be searched for > " )
      
    ( set! %key ( read ) )
      
    ( set! %result ( SearchBST 'action %key ) )
    
    ( if %result
         ( begin ( write %result ) 
                 ( newline )
         )
         #f
    )
    
  );let
  
);define DoSearchAction

; ( UpdateBST treeName key data )

( define ( DoUpdateCondition )

  ( let ( ( %key nil )
          ( %new-condition nil )
        );locals
  
    ( display-string "Key of the condition to update > " )
      
    ( set! %key ( read ) )
      
    ( display-string "The new condition > " )
    
    ( set! %new-condition ( read ) )
      
    ; ( UpdateBST treeName key data )
      
    ( UpdateBST 'condition %key %new-condition )
    
  );let
  
);define DoUpdateCondition

( define ( DoUpdateAction )

  ( let ( ( %key nil ) 
          ( %new-action-list nil )
        );locals
  
    ( display-string "Key of the action-list to update > " )
      
    ( set! %key ( read ) )
      
    ( display-string "The new action-list > " )
    
    ( set! %new-action-list ( read ) )
    
    ; ( UpdateBST treeName key data )
      
    ( UpdateBST 'action %key %new-action-list )
    
  );let
  
);define DoUpdateAction

; ( RemoveFromBST treeName key )

( define ( DoRemoveCondition )

  ( let ( ( %key nil )
        );locals
  
    ( display-string "Key of the condition to remove > " )
      
    ( set! %key ( read ) )
      
    ; ( RemoveFromBST treeName key )
      
    ( RemoveFromBST 'condition %key )
    
  );let
  
);define DoRemoveCondition

( define ( DoRemoveAction )

  ( let ( ( %key nil ) 
        );locals
  
    ( display-string "Key of the action-list to remove > " )
      
    ( set! %key ( read ) )
      
    ; ( RemoveFromBST treeName key )
      
    ( RemoveFromBST 'action %key )
    
  );let
  
);define DoRemoveAction

; ( ListDB-BST treeName )

( define ( DoListConditions )

  ; ( ListDB-BST treeName )
    
  ( ListDB-BST 'condition )
  
);define DoListConditions

( define ( DoListActions )

  ; ( ListDB-BST treeName )
    
  ( ListDB-BST 'action )
  
);define DoListActions

; ( ListKeysOfBST treeName )

( define ( DoListConditionKeys )

  ; ( ListKeysOfBST treeName )
    
  ( ListKeysOfBST 'condition )
  
);define DoListConditionKeys

( define ( DoListActionKeys )

  ; ( ListKeysOfBST treeName )
    
  ( ListKeysOfBST 'action )
  
);define DoListActionKeys

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( ExpertSystemShell )

  ( display-string
  
    ( string-append
      "------------------ Available choices are ------------------\n"
      "1 or DefineExpertise , 2 or RemoveExpertise , 3 or ListExpertiseNames ,\n"
      "4 or ListRuleSet , 5 or ReplaceRuleSet , 6 or ReplaceRuleOfRuleSet ,\n"
      "---\n"
      "7 or DefineCondition , 8 or DefineActionList ,\n"
      "9 or UpdateCondition , 10 or UpdateActionList ,\n"
      "11 or RemoveCondition , 12 or RemoveActionList ,\n"
      "13 or ListConditionKeys , 14 or ListActionListKeys ,\n"
      "15 or SearchCondition , 16 or SearchActionList ,\n"
      "17 or ListAllConditions , 18 or ListAllActionLists ,\n"
      "19 or DefineExpertiseFromDB, 20 or ReplaceRuleOfExpertiseWithNewlyComposedRuleUsingDB\n"
      "21 or Quit or quit\n"
      "Please enter the number (or item-name) of your choice > "
    )
    
  );display-string
  
  ( let ( ( %userChoice nil )
        );locals
  
    ( set! %userChoice (read))
    
    ( if ( or ( equal? %userChoice 21 )
              ( equal? %userChoice 'Quit )
              ( equal? %userChoice 'quit )
         )
         
         'Bye!
         
         ( begin
           ( cond ( ( or ( equal? %userChoice 1 )
                         ( equal? %userChoice 'DefineNewExpertise )
                    )
                    ( DoDefineNewExpertise )
                  )
                  ( ( or ( equal? %userChoice 2 )
                         ( equal? %userChoice 'RemoveExpertise )
                    )
                    ( DoRemoveExpertise )
                  )
                  ( ( or ( equal? %userChoice 3 )
                         ( equal? %userChoice 'ListExpertiseNames )
                    )
                    ( ListExpertiseNames )
                  )
                  ( ( or ( equal? %userChoice 4 )
                         ( equal? %userChoice 'ListRuleSet )
                    )
                    ( ListRuleSet )
                  )
                  ( ( or ( equal? %userChoice 5 )
                         ( equal? %userChoice 'ReplaceRuleSet )
                    )
                    ( DoReplaceRuleSet )
                  )
                  ( ( or ( equal? %userChoice 6 )
                         ( equal? %userChoice 'ReplaceRuleOfRuleSet )
                    )
                    ( DoReplaceRuleOfRuleSet )
                  )
                  ( ( or ( equal? %userChoice 7 )
                         ( equal? %userChoice 'DefineCondition )
                    )
                    ( DoDefineCondition )
                  )
                  ( ( or ( equal? %userChoice 8 )
                         ( equal? %userChoice 'DefineAction )
                    )
                    ( DoDefineAction )
                  )
                  ( ( or ( equal? %userChoice 9 )
                         ( equal? %userChoice 'UpdateCondition )
                    )
                    ( DoUpdateCondition )
                  )
                  ( ( or ( equal? %userChoice 10 )
                         ( equal? %userChoice 'UpdateAction )
                    )
                    ( DoUpdateAction )
                  )
                  ( ( or ( equal? %userChoice 11 )
                         ( equal? %userChoice 'RemoveCondition )
                    )
                    ( DoRemoveCondition )
                  )
                  ( ( or ( equal? %userChoice 12 )
                         ( equal? %userChoice 'RemoveAction )
                    )
                    ( DoRemoveAction )
                  )
                  ( ( or ( equal? %userChoice 13 )
                         ( equal? %userChoice 'ListConditionKeys )
                    )
                    ( DoListConditionKeys )
                  )
                  ( ( or ( equal? %userChoice 14 )
                         ( equal? %userChoice 'ListActionKeys )
                    )
                    ( DoListActionKeys )
                  )
                  ( ( or ( equal? %userChoice 15 )
                         ( equal? %userChoice 'SearchCondition )
                    )
                    ( DoSearchCondition )
                  )
                  ( ( or ( equal? %userChoice 16 )
                         ( equal? %userChoice 'SearchAction )
                    )
                    ( DoSearchAction )
                  )
                  ( ( or ( equal? %userChoice 17 )
                         ( equal? %userChoice 'ListAllConditions )
                    )
                    ( DoListConditions )
                  )
                  ( ( or ( equal? %userChoice 18 )
                         ( equal? %userChoice 'ListAllActions )
                    )
                    ( DoListActions ) ; ReplaceRuleOfExpertiseWithRuleComposedFromDB
                  )
                  ( ( or ( equal? %userChoice 19 )
                         ( equal? %userChoice 'DefineExpertiseFromDB )
                    )
                    ( DoDefineExpertiseFromDB )
                  )
                  ( ( or ( equal? %userChoice 20 )
                         ( equal? %userChoice 'ReplaceRuleOfExpertiseWithNewlyComposedRuleUsingDB )
                    )
                    ( DoReplaceRuleOfExpertiseWithNewlyComposedRuleUsingDB )
                  )
                  ( else 
                    ( display-string "Sorry! The choice you give is not in the list of choices.\n" ) 
                  )
           );cond
           
           ( ExpertSystemShell )
           
         );begin
         
    );if 7 or Quit or quit
    
  );let %userChoice
  
);ExpertSystemShell

( define ( DoDefineNewExpertise )

  ( let ( ( %nameOfExpertise nil )
          ( %listOfRules nil )
        );locals
        
    ( display-string "Name of the new expertise > " )
    ( set! %nameOfExpertise ( read ) )
    
    ( let ( ( %n ( $IndexOfExpertiseEntry %nameOfExpertise 1 $expertise-DB ) )
          );local
          
      ( if ( < %n 1 ) ; there is no expertise with name being '%nameOfExpertise' in $expertise-DB 
                      ; therefore, it is OK to add this new one into $expertise-DB
        ( begin
        
          ( display-string "The set of rules to be used by the new expertise > " )
          ( set! %listOfRules ( read ) )
          
          ; ( DefineExpertise nameOfExpertise listOfRules )
          ( DefineExpertise %nameOfExpertise %listOfRules )
    
        );begin
        
        ; %n >= 1
    
        ( PrintListOfSymbolsAsSentence 
          ( list 'Sorry. 'There 'is 'already 'an 'expertise 'named %nameOfExpertise 'in 'the 'expertise 'database. )
        )
        
      );if there is no expertise with name being '%nameOfExpertise' in $expertise-DB
      
    );let %n
      
  );let %nameOfExpertise, %listOfRules

);define DoDefineNewExpertise

( define ( DoRemoveExpertise )

  ( let ( ( %nameOfExpertise nil )
        );locals

    ( display-string "Name of the expertise to remove > " )
    ( set! %nameOfExpertise ( read ) )
    
    ( let ( ( %n ( $IndexOfExpertiseEntry %nameOfExpertise 1 $expertise-DB ) )
          );local
          
      ( if ( < %n 1 ) ; no expertise with name being '%nameOfExpertise' in $expertise-DB 
      
        ( PrintListOfSymbolsAsSentence 
          ( list 'Sorry. 'There 'is 'no 'expertise 'named %nameOfExpertise 'in 'the 'expertise 'database. )
        )
        
        ; %n >= 1 ; i.e., found the expertise named %nameOfExpertise in $expertise-DB
      
        ( begin
        
          ; 1. remove the description of this expertise from expertise-DB
          
          ( set! $expertise-DB 
                 ; ( $WithExpertiseRemoved nameOfExpertise list-of-expertise )
                 ( $WithExpertiseRemoved %nameOfExpertise $expertise-DB ) 
          )
          
          ; 2. somewhat unbound the function-binding of the symbol '%nameOfExpertise'
          
          ( eval ( list 'set! %nameOfExpertise 'nil ) ) 
          
          ; 3. feedback msg
    
          ( PrintListOfSymbolsAsSentence 
            ( list 'The 'expertise 'named %nameOfExpertise 'has 'been 'removed 'from 'the 'expertise 'database. )
          )
          
        );begin
        
      );if no expertise with name being '%nameOfExpertise' in $expertise-DB
      
    );let %n
    
  );let %nameOfExpertise
    
);define DoRemoveExpertise

( define ( $WithExpertiseRemoved nameOfExpertise list-of-expertise )

  ( cond ( ( null? list-of-expertise )
           nil
         )
         
         ( ( equal? ( car ( car list-of-expertise ) ) nameOfExpertise )
           ( cdr list-of-expertise ) ; removed
         )
         
         ( else
         
           ( cons ( car list-of-expertise )
                  ( $WithExpertiseRemoved nameOfExpertise 
                                          ( cdr list-of-expertise ) 
                  )
           )
           
         );else
         
  );cond
  
);define $WithExpertiseRemoved

( define ( ListRuleSet )

  ( let ( ( %expertiseName nil )
        );loals

    ( display-string "Please give the name of the expertise > " )
    ( set! %expertiseName ( read ) )
    
    ; ( RuleSetOf expertiseName )
    ( write ( RuleSetOf %expertiseName ) )
    ( newline )
  
  );let %expertiseName

);define ListRuleSet

( define ( DoReplaceRuleSet )

  ( let ( ( %nameOfExpertise nil )
          ( %listOfRules nil )
        );local
        
    ( display-string "Name of the expertise you want to replace its rule-set > " )
    ( set! %nameOfExpertise ( read ) )
    
    ( display-string "The new set of rules to be used by this expertise > " )
    ( set! %listOfRules ( read ) )
    
    ; ( $ReplaceRuleSet nameOfExpertise listOfRules )
    ( $ReplaceRuleSet %nameOfExpertise %listOfRules )
    
  );let %nameOfExpertise, %listOfRules

);define DoReplaceRuleSet

( define ( $ReplaceRuleSet nameOfExpertise listOfRules )

  ( let ( ( %n ( $IndexOfExpertiseEntry nameOfExpertise 1 $expertise-DB ) )
        );local
        
    ( if ( < %n 1 ) ; no expertise with name being 'nameOfExpertise' in $expertise-DB 
    
      ( PrintListOfSymbolsAsSentence 
        ( list 'There 'is 'no 'expertise 'named nameOfExpertise 'in 'the 'expertise 'database. )
      )
    
      ; got the entry-index of 'nameOfExpertise' in $expertise-DB
      
      ( let ( ( %code
                ( list 'define
                       ( cons nameOfExpertise '( n ) )
                       ( cons 'cond listOfRules )
                )
              )
              ( %expertise
                ( cons nameOfExpertise listOfRules )
              )
              ( %current-verbose-mode nil )
            );local-var
            
        ( set! %current-verbose-mode ( verbose? ) )
        ( verbose #f ) ; to disable the eval msg : abc defined
        ( eval %code ) ; redefine this expertise
        ( verbose %current-verbose-mode )
        
        ; update its description in the expertise-DB
        
        ( set! $expertise-DB  
               ( WithNthElementOfListReplaced %n $expertise-DB %expertise )
        )
        
        ( PrintListOfSymbolsAsSentence 
          ( list 'The 'rule-set 'of nameOfExpertise 'has 'been 'replaced. )
        )
      
        #t
        
      );let %code, %expertise
    
    );if %n < 1
    
  );let %n

);define $ReplaceRuleSet

( define ( DoReplaceRuleOfRuleSet )

  ( let ( ( %nameOfExpertise nil )
          ( %whichRule nil )
          ( %rule nil )
        );local
        
    ( display-string "Name of the expertise you want to replace its rule > " )
    ( set! %nameOfExpertise ( read ) )
    
    ( display-string "Ordering of the rule that is to be replaced - Please enter a number (e.g., 3) > " )
    ( set! %whichRule ( read ) )
    
    ( display-string "The new rule to be used in its place > " )
    ( set! %rule ( read ) )
    
    ; ( $ReplaceRuleOfRuleSet nameOfExpertise whichRule rule )
    ( $ReplaceRuleOfRuleSet %nameOfExpertise %whichRule %rule )
    
  );let %nameOfExpertise, %whichRule, %rule

);define DoReplaceRuleOfRuleSet

( define ( $ReplaceRuleOfRuleSet nameOfExpertise whichRule newRule )

  ( let ( ( %n ( $IndexOfExpertiseEntry nameOfExpertise 1 $expertise-DB ) )
        );local
        
    ( if ( < %n 1 ) ; no expertise with name being 'nameOfExpertise' in $expertise-DB 
    
      ( PrintListOfSymbolsAsSentence 
        ( list 'There 'is 'no 'expertise 'named nameOfExpertise 'in 'the 'expertise 'database. )
      )
    
      ; got the entry-index of 'nameOfExpertise' in $expertise-DB
      
      ( let ( ( %existingRuleSet ( RuleSetOf nameOfExpertise ) )
              ( %newRuleSet nil )
            );locals
      
        ( if ( < ( ListLength %existingRuleSet ) whichRule )
             
             ( PrintListOfSymbolsAsSentence 
               ( list 'The 'expertise 'named nameOfExpertise 'does 'not 'have 'this 'many 'rules. )
             )
              
             ( begin
             
               ( set! %newRuleSet
                      ; ( WithNthElementOfListReplaced n aList new-element )
                      ( WithNthElementOfListReplaced whichRule %existingRuleSet newRule )
               )
        
               ( let ( ( %code
                         ( list 'define
                                ( cons nameOfExpertise '( n ) )
                                ( cons 'cond %newRuleSet )
                         )
                       )
                       ( %revisedExpertise
                         ( cons nameOfExpertise %newRuleSet )
                       )
                       ( %current-verbose-mode nil )
                     );local-var
                     
                 ( set! %current-verbose-mode ( verbose? ) )
                 ( verbose #f ) ; to disable the eval msg : abc defined
                 ( eval %code ) ; redefine this expertise
                 ( verbose %current-verbose-mode )
                 
                 ; update its description in the expertise-DB
                 
                 ( set! $expertise-DB  
                        ; ( WithNthElementOfListReplaced n aList new-element )
                        ( WithNthElementOfListReplaced %n $expertise-DB %revisedExpertise )
                 )
                 
                 ( PrintListOfSymbolsAsSentence 
                   ( list 'The 'specified 'rule 'of nameOfExpertise 'has 'been 'replaced. )
                 )
               
                 #t
                 
               );let %code, %revisedExpertise
               
             );begin
             
        );if ( ListLength %existingRuleSet ) < whichRule
        
      );let %existingRuleSet %newRuleSet
    
    );if %n < 1
    
  );let %n

);define $ReplaceRuleOfRuleSet

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;=========================== BST ===============================

( begin 
  ( set! $condition-bst nil ) 
  ( set! $action-bst nil ) 
  ( set! $expertise-bst nil ) 
);begin
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( ListConditionBST )
  $condition-bst
);define ListConditionBST
  
( define ( ListActionBST )
  $action-bst
);define ListActionBST
  
; ( define ( ListExpertiseBST )
;   $expertise-bst
; );define ListExpertiseBST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( ClearConditionDB )
  ( set! $condition-bst nil )
);define ClearConditionDB
  
( define ( ClearActionDB )
  ( set! $action-bst nil )
);define ClearActionDB
  
; ( define ( ClearExpertiseDB )
; ( set! $expertise-bst nil )
; );define ClearExpertiseDB

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( ListConditionDB )
  ( ListDB-BST 'condition )
);define ListConditionDB
  
( define ( ListActionDB )
  ( ListDB-BST 'action )
);define ListActionDB
  
; ( define ( ListExpertiseDB )
;   ( ListDB-BST 'expertise )
; );define ListExpertiseDB

( define ( ListDB-BST treeName )

  ( let ( ( %bst ( cond ( ( equal? treeName 'condition )
                          $condition-bst
                        )
                        ( ( equal? treeName 'action )
                          $action-bst
                        )
                        ( ( equal? treeName 'expertise )
                          $expertise-bst
                        )
                        ; no ELSE to force an error msg when 'treeName' is none of the above
                 )
          )
        );local

    ( $ListDB-BST %bst )
    
  );let %bst
       
);define ListDB-BST

( define ( $ListDB-BST tree )

  ( if ( null? tree )
  
       nil
       
       ( let ( ( %left-sub ( car tree ) )
               ( %data-node ( cadr tree ) )
               ( %right-sub ( caddr tree ) )
             );locals
         
         ( $ListDB-BST %left-sub )
               
         ( display-string "------------------------\n" )
         
         ( display-string ( string-append "( "
                                          ( number->string ( car  ( car %data-node ) ) )
                                          "  "
                                          ( number->string ( cadr ( car %data-node ) ) )
                                          " )\n"
                          )
         )
         
         ( write ( cadr %data-node ) )
         ( newline )
         
         ( $ListDB-BST %right-sub )
         
         #t
         
       );let %left-sub %data-node %right-sub
       
  );if 'tree' is empty
      
);define $ListDB-BST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( KeyUsedInConditionDB? key )
  ( KeyUsedInBST? 'condition key )
);define KeyUsedInConditionDB?
  
( define ( KeyUsedInActionDB? key )
  ( KeyUsedInBST? 'action key )
);define KeyUsedInActionDB?
  
; ( define ( KeyUsedInExpertiseDB? key )
;   ( KeyUsedInBST? 'expertise key )
; );define KeyUsedInExpertiseDB?

( define ( KeyUsedInBST? treeName key )

  ( let ( ( %bst ( cond ( ( equal? treeName 'condition )
                          $condition-bst
                        )
                        ( ( equal? treeName 'action )
                          $action-bst
                        )
                        ( ( equal? treeName 'expertise )
                          $expertise-bst
                        )
                        ; no ELSE to force an error msg when 'treeName' is none of the above
                 )
          )
          ( %result nil )
        );local

    ( set! %result ( $KeyUsedInBST? %bst ( RealKey key ) )
    )
    
    ( if %result
    
         ( begin
           ( display-string "Yes. By\n" )
           %result
         )
         
         #f
         
    );if %result (is not nil)
    
  );let %bst
       
);define KeyUsedInBST?

( define ( $KeyUsedInBST? tree key )

; returns #f or non-#f

  ( if ( null? tree )
  
    #f
    
    ; 'tree' not empty
    
    ( let ( ( %left-sub ( car tree ) )
            ( %data-node ( cadr tree ) )
            ( %right-sub ( caddr tree ) )
            
            ( %key-of-data-node nil )
            
          );locals
          
      ( set! %key-of-data-node ( caar %data-node ) )
          
      ( cond ( ( = key %key-of-data-node )
               ( car %data-node )            ; i.e., #t
             )
             ( ( < key %key-of-data-node )
               ( $KeyUsedInBST? %left-sub key )
             )
             ( else
               ( $KeyUsedInBST? %right-sub key )
             )
      );cond

    );let %left-sub %data-node %right-sub %key-of-data-node
       
  );if 'tree' is empty
      
);define $KeyUsedInBST?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( ListKeysOfConditionDB )
  ( ListKeysOfBST 'condition )
);define ListKeysOfConditionDB
  
( define ( ListKeysOfActionDB )
  ( ListKeysOfBST 'action )
);define ListKeysOfActionDB
  
; ( define ( ListKeysOfExpertiseDB )
;   ( ListKeysOfBST 'expertise )
; );define ListKeysOfExpertiseDB

( define ( ListKeysOfBST treeName )

  ( let ( ( %bst ( cond ( ( equal? treeName 'condition )
                          $condition-bst
                        )
                        ( ( equal? treeName 'action )
                          $action-bst
                        )
                        ( ( equal? treeName 'expertise )
                          $expertise-bst
                        )
                        ; no ELSE to force an error msg when 'treeName' is none of the above
                 )
          )
        );local

    ( $ListKeysOfBST %bst )
    
  );let %bst
       
);define ListKeysOfBST

( define ( $ListKeysOfBST tree )

  ( if ( null? tree )
  
       nil
       
       ( let ( ( %left-sub ( car tree ) )
               ( %data-node ( cadr tree ) )
               ( %right-sub ( caddr tree ) )
             );locals
         
         ( $ListKeysOfBST %left-sub )
               
         ( display-string ( string-append "( "
                                          ( number->string ( car  ( car %data-node ) ) )
                                          "  "
                                          ( number->string ( cadr ( car %data-node ) ) )
                                          " )\n"
                          )
         )
         
         ( $ListKeysOfBST %right-sub )
         
         #t
         
       );let %left-sub %data-node %right-sub
       
  );if 'tree' is empty
      
);define $ListKeysOfBST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( SearchConditionDB key )
  ( SearchBST 'condition key )
);define SearchConditionDB
  
( define ( SearchActionDB key )
  ( SearchBST 'action key )
);define SearchActionDB
  
; ( define ( SearchExpertiseDB key )
;   ( SearchBST 'expertise key )
; );define SearchExpertiseDB

( define ( SearchBST treeName key )

; either print error msg and return nil
; or return the data found

  ( let ( ( %bst ( cond ( ( equal? treeName 'condition )
                          $condition-bst
                        )
                        ( ( equal? treeName 'action )
                          $action-bst
                        )
                        ( ( equal? treeName 'expertise )
                          $expertise-bst
                        )
                        ; no ELSE to force an error msg when 'treeName' is none of the above
                 )
          )
        );local

    ( let ( ( %key ( RealKey key ) ) ; instead of ( KeyPair key )
            ( %searchResult nil )
          );local
      
      ( set! %searchResult ( $SearchBST %key %bst )
      )
    
      ( if ( error-object? %searchResult )
      
          ( begin
          
            ( display-string ( string-append "SearchBST error : the key "
                                             ( number->string %key )
                                             " (originally "
                                             ( number->string key )
                                             ") is not on the BST.\n"
                             )
            ) 

            #f
          )
          
          %searchResult
          
      );if %searchResult is an error
          
    );let %key %searchResult 
    
  );let %bst
       
);define SearchBST

( define ( $SearchBST key tree )

; either return an error-object ( when data not found ) or the data found

  ( if ( null? tree ) ; tree to search is empty
  
       ( create-error-object ( string-append "$SearchBST error : the given key "
                                             ( number->string key )
                                             " is not on the BST."
                             )
       )
       
       ; tree to search is not empty
      
       ( let ( ( %left-sub ( car tree ) )
               ( %data-node ( cadr tree ) )
               ( %right-sub ( caddr tree ) )
               
               ( %keyOfData nil )
               
             );locals
         
         ( set! %keyOfData ( caar %data-node ) )
             
         ( cond
           ( ( = key %keyOfData )
             ( cadr %data-node )
           )
           ( ( < key %keyOfData )
             ( $SearchBST key %left-sub )
           )
           ( else
             ( $SearchBST key %right-sub )
           )
         ) ; cond
         
       );let %left-sub %data-node %right-sub %keyOfData
       
  );if the tree to search is empty
  
);define $SearchBST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( AddToConditionDB key condition )
  ( AddToBST 'condition key condition )
);define AddToConditionDB
  
( define ( AddToActionDB key action-list )
  ( AddToBST 'action key action-list )
);define AddToActionDB
  
; ( define ( AddToExpertiseDB key data )
;   ( AddToBST 'expertise key data )
; );define AddToExpertiseDB
  
( define ( AddToBST treeName key data )

; if successful, will return a string containing key-info

  ( let ( ( %bst ( cond ( ( equal? treeName 'condition )
                          $condition-bst
                        )
                        ( ( equal? treeName 'action )
                          $action-bst
                        )
                        ( ( equal? treeName 'expertise )
                          $expertise-bst
                        )
                        ; no ELSE to force an error msg when 'treeName' is none of the above
                 )
          )
        );local

    (let ( ( %key-pair ( KeyPair key ) ) ; must be '( KeyPair key ) to force randomness
           ( %result nil )
         )
         
      ( set! %result ( $AddToBST %key-pair data %bst ) )
         
      ( if ( error-object? %result )
      
        ( begin
        
          ( display-string %result ) 
          ( newline )
          
          #f
          
        );begin
        
        ; %result OK
        
        ( begin
        
          ( cond ( ( equal? treeName 'condition )
                   ( set! $condition-bst %result )
                 )
                 ( ( equal? treeName 'action )
                   ( set! $action-bst %result )
                 )
                 ( ( equal? treeName 'expertise )
                   ( set! $expertise-bst %result )
                 )
                 ; no ELSE to force an error msg when 'treeName' is none of the above
          )

          ( string-append "Key (short-version long-version) : ( " 
                          ( number->string ( car %key-pair ) )
                          "  "
                          ( number->string ( cadr %key-pair ) )
                          " )" 
          )
          
        );begin
        
      );if %result is an error-object
      
    );let %key-pair %result
    
  );let %bst
  
);define AddToBST

( define ( $AddToBST key-pair data tree )

; return the updated tree

  ( if ( null? tree)
  
    ( list nil ( list key-pair data ) nil )
    
    ( let ( ( %left-sub ( car tree ) )
            ( %data-node ( cadr tree ) )
            ( %right-sub ( caddr tree ) )
            
            ( %key ( car key-pair ) )
          );locals
          
      ( cond
      
        ( ( = %key ( caar %data-node ) )
        
          ( create-error-object ( string-append "$AddToBST error : the key "
                                                ( number->string ( car %key-pair ) )
                                                " (originally "
                                                ( number->string ( cadr %key-pair ) )
                                                ") is already in use by a node on the BST."
                                )
          )
          
        )
        
        ( ( < %key ( caar %data-node ) )
          ( list
            ( $AddToBST key-pair data %left-sub )
            %data-node
            %right-sub
          )
        )
        
        ( else
          ( list
            %left-sub
            %data-node
            ( $AddToBST key-pair data %right-sub )
          )
        ) 
        
      );cond
      
   );let %left-sub %data-node %right-sub
   
  );if tree is null
   
);define $AddToBST
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( UpdateConditionDB key data )
  ( UpdateBST 'condition key data )
);define UpdateConditionDB
  
( define ( UpdateActionDB key data )
  ( UpdateBST 'action key data )
);define UpdateActionDB
  
; ( define ( UpdateExpertiseDB key data )
;   ( UpdateBST 'expertise key data )
; );define UpdateExpertiseDB
  
( define ( UpdateBST treeName key data )

  ( let ( ( %bst ( cond ( ( equal? treeName 'condition )
                          $condition-bst
                        )
                        ( ( equal? treeName 'action )
                          $action-bst
                        )
                        ( ( equal? treeName 'expertise )
                          $expertise-bst
                        )
                        ; no ELSE to force an error msg when 'treeName' is none of the above
                 )
          )
        );local

    ( let ( ( %key ( RealKey key ) ) ; instead of ( KeyPair key )
            ( %result nil )
          );locals
          
      ( set! %result ( $UpdateBST %key data %bst ) )
      
      ( if ( error-object? %result )
      
        ( begin
        
          ( display-string ( string-append "UpdateBST error : the key "
                                           ( number->string %key )
                                           " (originally "
                                           ( number->string key )
                                           ") is not on the BST.\n"
                           )
          ) 
          
          #f
          
        );begin
        
        ( begin
        
          ( cond ( ( equal? treeName 'condition )
                   ( set! $condition-bst %result )
                 )
                 ( ( equal? treeName 'action )
                   ( set! $action-bst %result )
                 )
                 ( ( equal? treeName 'expertise )
                   ( set! $expertise-bst %result )
                 )
                 ; no ELSE to force an error msg when 'treeName' is none of the above
          )

          #t
          
        );begin
        
      );if error
      
    );let %key-pair %result
    
  );let %bst
  
);define UpdateBST
  
( define ( $UpdateBST key new-data tree )

; either return the updated tree or an error-object

  ( if ( null? tree )
  
    ( create-error-object
      ( string-append "$UpdateBST error : the key "
                      ( number->string key )
                      " is not on the BST."
      )
    )
    
    ( let ( ( %left-sub ( car tree ) )
            ( %data-node ( cadr tree ) )
            ( %right-sub ( caddr tree ) )
          )
          
      ( cond
      
        ( ( = key ( caar %data-node ) )
          ( list
            %left-sub
            ( list ( car %data-node ) new-data )
            %right-sub
          )
        )
        
        ( ( < key ( caar %data-node ) )
          ( list
            ( $UpdateBST key new-data %left-sub )
            %data-node
            %right-sub
          )
        )
        
        ( else
        
          ( list
            %left-sub
            %data-node
            ( $UpdateBST key new-data %right-sub)
          )
        )
        
      );cond
      
    );let %left-sub %data-node %right-sub
   
  );if tree is empty
   
);define $UpdateBST
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

( define ( FindMaxBSTnode tree )

  ( if ( null? tree )
  
    ( create-error-object "FindMaxBSTnode error : Cannot find max on an empty tree." )
    
    ( $FindMaxBSTnode tree )
    
  );if tree is null  
  
);define FindMaxBSTnode

( define ( $FindMaxBSTnode tree )

; prerequisit : the given 'tree' is not empty

  ( let ( ( %data-node ( cadr tree ) )
          ( %right-sub ( caddr tree ) )
        )
        
    ( if ( null? %right-sub )
    
      %data-node
      
      ( $FindMaxBSTnode %right-sub )
      
    );if
    
  );let %data-node %right-sub
    
);define $FindMaxBSTnode

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( FindMinBSTnode tree )

  ( if ( null? tree )
  
    ( create-error-object "FindMinBSTnode error : Cannot find min on an empty tree" )
    
    ( $FindMinBSTnode tree )
   
  );if tree is null
   
);define FindMinBSTnode
  
( define ( $FindMinBSTnode tree )

; prerequisit : the given 'tree' is not empty

  ( let ( ( %data-node ( cadr tree ) )
          ( %left-sub ( car tree ) )
        )
        
    ( if ( null? %left-sub )
    
      %data-node
      
      ( $FindMinBSTnode %left-sub )
      
    );if
    
  );let %data-node %left-sub
   
);define $FindMinBSTnode

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( RemoveFromConditionDB key )
  ( RemoveFromBST 'condition key )
);define RemoveFromConditionDB
  
( define ( RemoveFromActionDB key )
  ( RemoveFromBST 'action key )
);define RemoveFromActionDB
  
; ( define ( RemoveFromExpertiseDB key )
;   ( RemoveFromBST 'expertise key )
; );define RemoveFromExpertiseDB
  
( define ( RemoveFromBST treeName key )

; 'key' is allowed to be any natural number

  ( let ( ( %bst ( cond ( ( equal? treeName 'condition )
                          $condition-bst
                        )
                        ( ( equal? treeName 'action )
                          $action-bst
                        )
                        ( ( equal? treeName 'expertise )
                          $expertise-bst
                        )
                        ; no ELSE to force an error msg when 'treeName' is none of the above
                 )
          )
        );local

    ( set! key ( RealKey key ) ) ; instead of ( KeyPair key )
    
    ( if ( null? %bst )
        
      ( create-error-object "RemoveFromBST : Cannot remove a node from an empty tree." )
          
      ( let ( ( %result ( $RemoveFromBST key %bst ) )
            )
            
        ( if ( error-object? %result )
        
          ( begin
          
            ( display-string %result )
            ( newline )
            
            #f
            
          );begin
          
          ( begin
          
            ( cond ( ( equal? treeName 'condition )
                     ( set! $condition-bst %result )
                   )
                   ( ( equal? treeName 'action )
                     ( set! $action-bst %result )
                   )
                   ( ( equal? treeName 'expertise )
                     ( set! $expertise-bst %result )
                   )
                   ; no ELSE to force an error msg when 'treeName' is none of the above
            )

            #t
            
          );begin
          
        );if %result is an error-object
        
      );let %result
      
    ); if %bst is empty
    
  );let %bst
    
);define RemoveFromBST
  
( define ( $RemoveFromBST key tree )

; return the resulting tree

; prerequisite : 'tree' is not empty

; assumption : there is at most one node with the designated key on this tree

  ( let ( ( %left-sub ( car tree ) )
          ( %data-node ( cadr tree ) )
          ( %right-sub ( caddr tree ) )
        );locals
       
    ( cond
    
      ( ( = key ( caar %data-node ) ) ; got it (the node we must remove from 'tree')!
      
        ( if ( not ( null? %left-sub ) )
          
          ( let ( ( %max-node ( FindMaxBSTnode %left-sub ) )
                );local
            
            ( list
              ( $RemoveFromBST ( caar %max-node ) %left-sub )
              %max-node
              %right-sub
            )
            
          );let %max-node be max data node on %left-sub
        
          ; %left-sub is empty
          
          ( if ( not ( null? %right-sub ) )
            
            ( let ( ( %min-node ( FindMinBSTnode %right-sub ) )
                  )
              ( list
                %left-sub
                %min-node
                ( $RemoveFromBST ( caar %min-node ) %right-sub )
              )
              
            );let %min-node be min data node on %right-sub
          
            ; %right-sub is empty too
            
            nil   ; since both %right-sub and %left-sub are empty trees,
                  ; the result of romoving this %data-node is an empty tree
              
          );if %right-sub is not empty
              
        );if %left-sub is not empty
          
      ); %key is same as the key stored in %data-node
      
      ( ( < key ( caar %data-node ) )
      
        ( if ( null? %left-sub )
          
          ( begin
          
            ( create-error-object ( string-append
                                    "$RemoveFromBST error : the given key "
                                    ( number->string %key )
                                    " does not exist on the BST."
                                  )
            )
            
            nil
            
          );begin
          
          ; %left-sub is not empty
      
          ( list
            ( $RemoveFromBST key %left-sub )
            %data-node
            %right-sub
          )
          
        );if %left-sub is empty
        
      ); key is smaller than the key stored in %data-node
      
      ( else   
      
        ( if ( null? %right-sub )
          
          ( begin
          
            ( create-error-object ( string-append
                                    "$RemoveFromBST error : the given key "
                                    ( number->string %key )
                                    " does not exist on the BST."
                                  )
            )
            
            nil
            
          );begin
          
          ; %right-sub is not empty
      
          ( list
            %left-sub
            %data-node
            ( $RemoveFromBST key %right-sub )
          )
          
        );if %right-sub is empty
        
      );else key is greater than the key stored in %data-node
      
    );cond
    
  );let %left-sub %data-node %right-sub %key
       
);define $RemoveFromBST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; put in initial DB entries to prevent BST from becoming linear shaped

( set! condition-7652145
       '( DivisibleBy
          n
          7652145
        )
) ; set!

; ( AddToConditionDB (+ (/ $%%% 2) $%%%) condition-7652145 )

( AddToConditionDB ( + ( / ( - $%%% ( % $%%% 2 ) )
                           2
                       ) 
                       $%%%
                   ) 
                   condition-7652145 
)

; ( AddToConditionDB (+ (/ $%%% 4) $%%%) condition-7652145 )

( AddToConditionDB ( + ( / ( - $%%% ( % $%%% 4 ) )
                           4
                       ) 
                       $%%%
                   ) 
                   condition-7652145 
)

; ( AddToConditionDB (+ (* (/ $%%% 4) 3) $%%%) condition-7652145 )

( AddToConditionDB ( + ( * ( / ( - $%%% ( % $%%% 4 ) )
                               4
                           ) 
                           3
                       )
                       $%%%
                   ) 
                   condition-7652145 
)

( set! condition-7652145 nil )

( set! a 20 )
( set! b 30 )

( set! action-7652145
       '( ( set! a ( + n a ) )
          ( set! b ( + n a b ) )
        )
) ; set!

; ( AddToActionDB (+ (/ $%%% 2) $%%%) action-7652145 )

( AddToActionDB ( + ( / ( - $%%% ( % $%%% 2 ) )
                           2
                       ) 
                       $%%%
                   ) 
                   action-7652145 
)

; ( AddToActionDB (+ (/ $%%% 4) $%%%) action-7652145 )

( AddToActionDB ( + ( / ( - $%%% ( % $%%% 4 ) )
                           4
                       ) 
                       $%%%
                   ) 
                   action-7652145 
)

; ( AddToActionDB (+ (* (/ $%%% 4) 3) $%%%) action-7652145 )

( AddToActionDB ( + ( * ( / ( - $%%% ( % $%%% 4 ) )
                               4
                           ) 
                           3
                       )
                       $%%%
                   ) 
                   action-7652145 
)

( set! action-7652145 nil )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Utilities ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



( ExpertSystemShell )
13  ; ListConditionKeys
14  ; ListActionListKeys
15  ; SearchCondition
661
16  ; SearchActionList
473
17  ; ListAllConditions
18  ; ListAllActionLists
3   ; ListExpertiseNames
4   ; ListRuleSet
NoSuchExpertise
4   ; ListRuleSet
ExampleExpertise
4   ; ListRuleSet
Expertise-01
quit

(ExampleExpertise 35000)
(Expertise-01 35001)
(Expertise-01 35017)

( ExpertSystemShell )
7  ; DefineCondition
3518792
( >= n 200000 )

7  ; DefineCondition
5478952
( >= n 100000 )

7  ; DefineCondition
9157342
( >= n 50000 )

7  ; DefineCondition
1749826
else

7  ; DefineCondition
4865217
( >= n 300000 )

13 ; ListConditionKeys

19 ; DefineExpertiseFromDB
TryTrySee ; Name of the to-be-defined-expertise
y ; Define a new rule from Condition/Action-list in DB? (Y/N)
94 ; Key of the condition to search
282 ; Key of the action-list to search
y ; Define a new rule from Condition/Action-list in DB? (Y/N)
189 ; Key of the condition to search
94 ; Key of the action-list to search
y ; Define a new rule from Condition/Action-list in DB? (Y/N)
362 ; Key of the condition to search ; was 282
189 ; Key of the action-list to search
n ; Define a new rule from Condition/Action-list in DB? (Y/N)
; The expertise 'TryTrySee' has been established.
quit
; Bye!

a b
(TryTrySee 35487) a b
(TryTrySee 35487) a b
(TryTrySee 35487) a b



(ExpertSystemShell)
3 ; ListExpertiseNames
4 ; ListRuleSet
TryTrySee ; name of the expertise

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

8 ; DefineActionList
49256587
       ( ; ( >= n 200000 )               ; was : condition
       
         ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
               );local
         
           ( cond   
                  
             ( ( and ( <= 300000 %p ) ( <= %p 400000 ) 
               )
               
               #t ; OK
             )
             
             ( ( < %p 300000 )
             
               ( cond
                 ( ( not ( TopSize? ) )
                   ( UpgradeSize )
                 )
                 ( ( not ( TopPrice? ) )
                   ( UpgradePrice )
                 )
                 ( ( not ( TopQuality? ) )
                   ( UpgradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; %p < 300000
             
             ( ( < 400000 %p )
             
               ( cond
                 ( ( not ( BottomSize? ) )
                   ( DowngradeSize )
                 )
                 ( ( not ( BottomPrice? ) )
                   ( DowngradePrice )
                 )
                 ( ( not ( BottomQuality? ) )
                   ( DowngradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; 400000 < %p
             
             ; no ELSE
             
           );cond
           
           ( TransactionState )
           
         );let %p
             
       ) ; list 1 of actions for 'OverSpent' ; condition-action pair 1 with condition : n >= 200000
       
8 ; DefineActionList
398574

       ; list 2 of actions
       
       ( ; ( >= n 100000 )               ; was : condition
       
         ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
               );local
         
           ( cond   
                  
             ( ( and ( <= 200000 %p ) ( <= %p 300000 ) 
               )
               
               #t ; OK
             )
             
             ( ( < %p 200000 )
             
               ( cond
                 ( ( not ( TopSize? ) )
                   ( UpgradeSize )
                 )
                 ( ( not ( TopPrice? ) )
                   ( UpgradePrice )
                 )
                 ( ( not ( TopQuality? ) )
                   ( UpgradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; %p < 200000
             
             ( ( < 300000 %p )
             
               ( cond
                 ( ( not ( BottomSize? ) )
                   ( DowngradeSize )
                 )
                 ( ( not ( BottomPrice? ) )
                   ( DowngradePrice )
                 )
                 ( ( not ( BottomQuality? ) )
                   ( DowngradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; 300000 < %p
             
             ; no ELSE
             
           );cond
           
           ( TransactionState )
           
         );let %p ; action
             
       ) ; list 2 of actions of 'OverSpent'; condition-action pair 2 ; with condition : n >= 100000

8
1124365
       ; list 3 of actions
       
       ( ; ( >= n 50000 )               ; was : condition
       
         ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
               );local
         
           ( cond   
                  
             ( ( and ( <= 50000 %p ) ( <= %p 100000 ) 
               )
               
               #t ; OK
             )
             
             ( ( < %p 50000 )
             
               ( cond
                 ( ( not ( TopSize? ) )
                   ( UpgradeSize )
                 )
                 ( ( not ( TopPrice? ) )
                   ( UpgradePrice )
                 )
                 ( ( not ( TopQuality? ) )
                   ( UpgradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; %p < 50000
             
             ( ( < 100000 %p )
             
               ( cond
                 ( ( not ( BottomSize? ) )
                   ( DowngradeSize )
                 )
                 ( ( not ( BottomPrice? ) )
                   ( DowngradePrice )
                 )
                 ( ( not ( BottomQuality? ) )
                   ( DowngradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; 100000 < %p
             
             ; no ELSE
             
           );cond
           
           ( TransactionState )
           
         );let %p ; action
             
       ) ; list 3 of actions ; condition-action pair 3 ; with condition : n >= 50000

8
9258674
       ; list 4 of actions
       
       ( ; else                         ; was : condition ( n < 50000 )
       
         ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
               );local
         
           ( cond   
                  
             ( ( and ( <= 30000 %p ) ( <= %p 50000 ) 
               )
               
               #t ; OK
             )
             
             ( ( < %p 30000 )
             
               ( cond
                 ( ( not ( TopSize? ) )
                   ( UpgradeSize )
                 )
                 ( ( not ( TopPrice? ) )
                   ( UpgradePrice )
                 )
                 ( ( not ( TopQuality? ) )
                   ( UpgradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; %p < 30000
             
             ( ( < 50000 %p )
             
               ( cond
                 ( ( not ( BottomSize? ) )
                   ( DowngradeSize )
                 )
                 ( ( not ( BottomPrice? ) )
                   ( DowngradePrice )
                 )
                 ( ( not ( BottomQuality? ) )
                   ( DowngradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; 50000 < %p
             
             ; no ELSE
             
           );cond
           
           ( TransactionState )
           
         );let %p ; action
             
       ) ; list 4 of actions ; condition-action pair 3 ; with condition : else (i.e., n < 50000)

8
4545125
     ; rule 1 of Exaggerated

     ( ; ( >= n 300000 )               ; condition
     
       ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
             );local
       
         ( cond   
                
           ( ( and ( <= 500000 %p ) ( <= %p 800000 ) 
             )
             
             #t ; OK
           )
           
           ( ( < %p 500000 )
           
             ( cond
               ( ( not ( TopSize? ) )
                 ( UpgradeSize )
               )
               ( ( not ( TopPrice? ) )
                 ( UpgradePrice )
               )
               ( ( not ( TopQuality? ) )
                 ( UpgradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; %p < 500000
           
           ( ( < 800000 %p )
           
             ( cond
               ( ( not ( BottomSize? ) )
                 ( DowngradeSize )
               )
               ( ( not ( BottomPrice? ) )
                 ( DowngradePrice )
               )
               ( ( not ( BottomQuality? ) )
                 ( DowngradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; 800000 < %p
           
           ; no ELSE
           
         );cond
         
         ( TransactionState )
         
       );let %p
           
     ) ; rule 1 of Exaggerated ; condition-action pair 1 with condition : n >= 200000

8
8416872
     ; rule 2 of Exaggerated

     ( ; ( >= n 200000 )               ; condition
     
       ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
             );local
       
         ( cond   
                
           ( ( and ( <= 400000 %p ) ( <= %p 600000 ) 
             )
             
             #t ; OK
           )
           
           ( ( < %p 400000 )
           
             ( cond
               ( ( not ( TopSize? ) )
                 ( UpgradeSize )
               )
               ( ( not ( TopPrice? ) )
                 ( UpgradePrice )
               )
               ( ( not ( TopQuality? ) )
                 ( UpgradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; %p < 400000
           
           ( ( < 600000 %p )
           
             ( cond
               ( ( not ( BottomSize? ) )
                 ( DowngradeSize )
               )
               ( ( not ( BottomPrice? ) )
                 ( DowngradePrice )
               )
               ( ( not ( BottomQuality? ) )
                 ( DowngradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; 600000 < %p
           
           ; no ELSE
           
         );cond
         
         ( TransactionState )
         
       );let %p ; action
           
     ) ; rule 2 of Exaggerated ; condition-action pair 2 ; with condition : n >= 100000
     
8
65623565
5545587
     ; rule 3 of Exaggerated

     ( ; ( >= n 100000 )               ; condition
     
       ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
             );local
       
         ( cond   
                
           ( ( and ( <= 300000 %p ) ( <= %p 400000 ) 
             )
             
             #t ; OK
           )
           
           ( ( < %p 300000 )
           
             ( cond
               ( ( not ( TopSize? ) )
                 ( UpgradeSize )
               )
               ( ( not ( TopPrice? ) )
                 ( UpgradePrice )
               )
               ( ( not ( TopQuality? ) )
                 ( UpgradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; %p < 300000
           
           ( ( < 400000 %p )
           
             ( cond
               ( ( not ( BottomSize? ) )
                 ( DowngradeSize )
               )
               ( ( not ( BottomPrice? ) )
                 ( DowngradePrice )
               )
               ( ( not ( BottomQuality? ) )
                 ( DowngradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; 400000 < %p
           
           ; no ELSE
           
         );cond
         
         ( TransactionState )
         
       );let %p ; action
           
     ) ; rule 3 of Exaggerated ; condition-action pair 3 ; with condition : n >= 200000

8
2653485
     ; rule 4 of Exaggerated

     ( ; else                         ; condition ( n < 200000 )
     
       ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
             );local
       
         ( cond   
                
           ( ( and ( <= 200000 %p ) ( <= %p 300000 ) 
             )
             
             #t ; OK
           )
           
           ( ( < %p 200000 )
           
             ( cond
               ( ( not ( TopSize? ) )
                 ( UpgradeSize )
               )
               ( ( not ( TopPrice? ) )
                 ( UpgradePrice )
               )
               ( ( not ( TopQuality? ) )
                 ( UpgradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; %p < 200000
           
           ( ( < 300000 %p )
           
             ( cond
               ( ( not ( BottomSize? ) )
                 ( DowngradeSize )
               )
               ( ( not ( BottomPrice? ) )
                 ( DowngradePrice )
               )
               ( ( not ( BottomQuality? ) )
                 ( DowngradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; 300000 < %p
           
           ; no ELSE
           
         );cond
         
         ( TransactionState )
         
       );let %p ; action
           
     ) ; rule 4 of Exaggerated ; condition-action pair 3 ; with condition : else (i.e., n < 200000)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

14 ; ListActionListKeys

19 ; DefineExpertiseFromDB
OverSpent
y
156
231
y
128
245
y
323
251
y
362
83
n

19 ; DefineExpertiseFromDB
Exaggerated
y
373
157
y
156
40
y
128
59
y
362
106
n

quit

(ResetTransactionState)

(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)

(Exaggerated 251476)
(Exaggerated 251476)

(OverSpent 78254)
(OverSpent 78254)

(Exaggerated 78254)

(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)

(Exaggerated 38255)

(ExpertSystemShell)

11 ; RemoveCondition
323
11 ; RemoveCondition
189
13 ; ListConditionKeys
12 ; RemoveActionList
231
12 ; RemoveActionList
251
12 ; RemoveActionList
40
14 ; ListActionListKeys
15 ; SearchCondition
9157342
15 ; SearchCondition
5478952
16 ; SearchActionList
78945
16 ; SearchActionList
1124365
16 ; SearchActionList
4545125
quit

(ResetTransactionState)

(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)

(Exaggerated 251476)
(Exaggerated 251476)

(OverSpent 78254)
(OverSpent 78254)

(Exaggerated 78254)

(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)

(Exaggerated 38255)

(ResetTransactionState)

(Exaggerated 1251476)
(Exaggerated 1251476)
(Exaggerated 1251476)
(Exaggerated 1251476)

(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)

(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( ++ n m )
  ( + n m 1 )
);define ++

( ExpertSystemShell )

8 ; DefineActionList
7457747

( ; list of actions

  ( if ( > ( % ( ++ n 29 ) 20 
           ) 
           10 
       )
    ( begin
    
      ( cond
        ( ( not ( TopPrice? ) )
          ( UpgradePrice )
        )
        ( ( not ( TopSize? ) )
          ( UpgradeSize )
        )
        ( ( not ( TopQuality? ) )
          ( UpgradeQuality )
        )
        ; no ELSE 
      );cond
      
      ( TransactionState )
      
    ); begin
    
    ( begin
    
      ( cond
        ( ( not ( BottomPrice? ) )
          ( DowngradePrice )
        )
        ( ( not ( BottomSize? ) )
          ( DowngradeSize )
        )
        ( ( not ( BottomQuality? ) )
          ( DowngradeQuality )
        )
        ; no ELSE 
      );cond
      
      ( TransactionState )
      
    );begin
    
  );if
  
);list of actions

20 ; ReplaceRuleOfExpertiseWithNewlyComposedRuleUsingDB
OverSpent ; Name of the expertise
4 ; Ordering of the rule that is to be replaced
362 ; key of the condition
164 ; key of the action-list

quit

(ResetTransactionState)

(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)

(Exaggerated 251476)
(Exaggerated 251476)

(OverSpent 78254)
(OverSpent 78254)
(OverSpent 78254)
(OverSpent 78254)
(OverSpent 78254)
(OverSpent 78254)
(OverSpent 78254)
(OverSpent 78254)
(OverSpent 78254)
(OverSpent 78254)
(OverSpent 78254)
(OverSpent 78254)

(Exaggerated 78254)
(Exaggerated 78254)
(Exaggerated 78254)
(Exaggerated 78254)
(Exaggerated 78254)
(Exaggerated 78254)
(Exaggerated 78254)
(Exaggerated 78254)
(Exaggerated 78254)

(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)

(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)

(ResetTransactionState)

(Exaggerated 1251476)
(Exaggerated 1251476)
(Exaggerated 1251476)
(Exaggerated 1251476)

(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)

(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)
(OverSpent 18254)

(exit)
