2017 spring PL project (OurScheme) - Project 1

Due : 3/20 // was : 4/18(六) midnight (23:59)

  // You are to implement something like the following
                 
  // 'exp' is a pointer that points to a linked list data structure;
  // The linked list data structure results from reading in
  // the user's input.

  Print 'Welcome to OurScheme!'
  Print '\n'
  Print '> '

  repeat
  
    ReadSExp(exp);
    PrintSExp(exp); // You must "pretty print" this S-expression.
    Print '> '
    
  until (OR (user entered '(exit)')
            (END-OF-FILE encountered)
        )

  Print '\n'
  Print 'Thanks for using OurScheme!' // Doesn't matter whether there is an
                                      // '\n' at the end
2. Syntax of OurScheme

terminal :
  LEFT-PAREN       // '('
  RIGHT-PAREN      // ')'
  INT              // e.g., '123', '+123', '-123'
  STRING           // "string's (example)." (strings do not extend across lines)
  DOT              // '.'
  FLOAT            // '123.567', '123.', '.567', '+123.4', '-.123'
  NIL              // 'nil' or '#f', but not 'NIL' nor 'nIL'
  T                // 't' or '#t', but not 'T' nor '#T'
  QUOTE            // '
  SYMBOL           // a consecutive sequence of printable characters that are
                   // not numbers, and do not contain '(', ')', single-quote,
                   // double-quote and white-spaces ; 
                   // Symbols are case-sensitive 
                   // (i.e., uppercase and lowercase are different);

Note :

  With the exception of strings, token are separated by the following "separators" :
    (a) one or more white-spaces
    (b) '('                               (note : '(' is a token by itself)
    (c) ')'                               (note : ')' is a token by itself)
    (d) the single-quote character (')    (note : it is a token by itself)
    (e) the double-quote character (")    (note : it starts a STRING)

Examples :

  '3.25' is a FLOAT.
  '3.25a' is a SYMBOL.
  'a.b' is a SYMBOL.
  '#f' is NIL
  '#fa' (alternatively, 'a#f') is a SYMBOL.

Note :

  '.' can mean several things : 
    it is either part of a FLOAT or part of a SYMBOL or a DOT.
    
  It means a DOT only when it "stands alone".
  
  '#' can also mean two things :
    it is either part of NIL (or T) or part of a SYMBOL.
  
  It is part of NIL (or T) only when it is '#t' or '#f' that "stand alone".
  
<S-exp> ::= <ATOM> 
            | LEFT-PAREN <S-exp> { <S-exp> } [ DOT <S-exp> ] RIGHT-PAREN
            | QUOTE <S-exp>
            
<ATOM>  ::= SYMBOL | INT | FLOAT | STRING 
            | NIL | T | LEFT-PAREN RIGHT-PAREN

Once the attempt to read in an S-expression fails, the line 
containing the error-char is ignored.  Start to read in an 
S-expression from the next input line.

Note : a quoted S-expression '... is the same as (quote ...)

   a. In C, the basic program building block is a statement.
      In OurScheme, the basic program building block is 
      an S-expression (S-exp, for short).
      
   b. An S-exp is either an atom, a list, or a dotted pair.
   
   c. An atom is either an integer (e.g., 123), a float
      (e.g., 12.34 or 12. or .34), a string (e.g., "Hi, there!"), 
      or a symbol (e.g., abc).
      
   d. Abc, abc, aBc, a-B!c?, !??, t, nil are examples of symbols
   
      // Blanks and line-returns ("white-space characters") are 
      // considered delimiters
      
      // Upper case and lower case are different, e.g., aB, AB, Ab,
      // ab are all different symbols.
      
      // Each symbol may or may not be bound to an S-exp.
      
      // When I say that a symbol abc is bound to the S-exp
      // (abc "Hi there" (5 3)),
      // you could take what I mean to be that the "value" of abc
      // is (abc "Hi there" (5 3)).
      
      // "Binding" (rather than "value") is a better way of saying 
      // what the situation really is.  
      
      // t, nil are two system-defined symbols 
      //   (t for "true" and nil for "false")
      // They cannot be bound to any S-exp (i.e., they cannot be 
      // treated like user-defined symbols and cannot have values).
      
      // t is also written as #t, meaning "true"
      // nil is also written as () or #f, meaning "false"
      // In other word,
      //   these two are the same : t   #t
      //   these three are the same : nil   #f   ()
      
      // OurScheme understands both 't' and '#t', but it only prints '#t'
      // OurScheme understands all these three : 'nil', '#f', '()',
      //   but it only prints 'nil'.     
      
      // Side remark :
      //   (True) Scheme uses #t, #f and ()
      //   "Other Lisps" use t, nil and ()
      
   e. An 「S-exp sequence」 is of the form
         S1 S2 S3 ... Sn
      where each Si is an S-exp.
      // e.g., (1) 1 (1 . 1)
      // e.g., 1 2 (3 4 (5))
      // Each of the above S-exp sequence contains three S-exp

   f. A dotted pair is of the form
        (SS1 . S2)
      where S2 is an S-exp, whereas SS1 is an 「S-exp sequence」.
      // Note that there is a dot between SS1 and S2,
      //      with one or more spaces in between
      // e.g., (1 . 2)
      // e.g., (1  2  3  4  . 5)
      // e.g., (1  2  3  4  . ())
      // e.g., (1 . (2 . (3 . abc)))
      // e.g., (1 2 3 . abc)
      // e.g., ((1) (2 (3)) . (abc))
      // e.g., ((1) (2 (3)) . (nil))
      // e.g., ((1) (2 (3)) . nil)
      
   g. The following notations of dotted pairs are equivalent.
      
      (S1 S2 S3 S4 . S5)
      (S1 . (S2 . (S3 . (S4 . S5))))
      
   h. Comment :
      What we refer to as a "dotted pair" is different from what
      other professionals refer to as a "dotted pair".
      
      What other professionals mean by a dotted pair is just
      (S1 . S2), where S1 and S2 are S-exp.
      
   i. A list is of the form
        (SS1)
      where SS1 is an 「S-exp sequence」.
      // Note : () is known as "the empty list"
      // For historical reasons, () is defined to be the same
      //   as nil or #f, meaning "false"
      
   j. A list (S1 S2 ... Sn) is actually a short-handed
      notation for the following dotted pair
        (S1 . (S2 . (...(Sn . nil)))...)))
      In other words, a list is actually a special kind of
      dotted pair.
      
      Another way of writing the list (S1 S2 ... Sn) is
        (S1 S2 ... Sn . nil)
        
      // In other word, there are three (seven?) ways for writing
      // the same list.
      //   (S1 S2 S3 S4 S5)
      //   (S1 . (S2 . (S3 . (S4 . (S5 . nil)))))
      //   (S1 . (S2 . (S3 . (S4 . (S5 . #f )))))
      //   (S1 . (S2 . (S3 . (S4 . (S5 . () )))))
      //   (S1 S2 S3 S4 S5 . nil)
      //   (S1 S2 S3 S4 S5 . #f)
      //   (S1 S2 S3 S4 S5 . ())
        
   k. When the system prints out a dotted pair, it
      always tries to print it in list-like format.
      
      For example, if the dotted pair is
        (1 . (2 . (3 . (4 . 5))))
      Then the system prints it as
        (1 2 3 4 . 5)
        
      But if the dotted pair is
        (1 . (2 . (3 . (4 . nil))))
      The system does not print it as
        (1 2 3 4 . nil)
      Instead, the system prints it as
        (1 2 3 4)
   
   l. Line comments
   
   A line comment begins with ';' until the end-of-line.
   This ';' must be such that either it is the very first 
   character of the line or there is a separater preceding this ';'
   on this line. 
   
   (Therefore, for example, 'ab;b' is a symbol,
    while 'ab ;b' is the symbol 'ab' followed by a 
    line comment that starts with ';b'.)
        
3. Here are some examples of what your program should
   do for project 1. (The following assumes that your program
   runs interactively.)

Welcome to OurScheme!

> (1 . (2 . (3 . 4)))
( 1
  2
  3
  .
  4
)

> (1 . (2 . (3 . nil)))
( 1
  2
  3
)

> (1 . (2 . (3 . ())))
( 1
  2
  3
)

> (1 . (2 . (3 . #f)))
( 1
  2
  3
)

> a
a

> t
#t

> #t
#t

> nil
nil

> ()
nil

> #f
nil

> (t () . (1 2 3))
( #t
  nil
  1
  2
  3
)

> (t . nil . (1 2 3))
ERROR (unexpected character) : line 1 column 10 character '.'

> ((1 2 3) . (4 . (5 . nil)))
( ( 1
    2
    3
  )
  4
  5
)

> ((1 2 3) . (4 . (5 . ())))
( ( 1
    2
    3
  )
  4
  5
)

> (12.5       . (4 . 5))
( 12.500
  4
  .
  5
)

> (10 12.())   ; same as : ( 10 12. () )
( 10
  12.000
  nil
)

> (10 ().125)   ; same as : ( 10 () .125 )
( 10
  nil
  0.125
)

> ( 1 2.5)
( 1
  2.500
)

> ( 1 2.a)
( 1
  2.a
)

> (1 2.25.5.a)
( 1
  2.25.5.a
)

> (12 (    . 3))
ERROR (unexpected character) : line 1 column 11 character ' '

> "Hi"
"Hi"

> "(1 . 2   . 3)"
"(1 . 2   . 3)"

> (((1 . 2) 
    . ((3 4) 
       . 
       (5 . 6)
      )
   ) 
   . (7 . 8)
  )
( ( ( 1
      .
      2
    )
    ( 3
      4
    )
    5
    .
    6
  )
  7
  .
  8
)

> ())
nil

> ERROR (unexpected character) : line 1 column 1 character ')'

> (Hi there ! How are you ?)
( Hi
  there
  !
  How
  are
  you
  ?
)

> (Hi there! How are you?)
( Hi
  there!
  How
  are
  you?
)

> (Hi! (How about using . (Lisp (instead of . C?))))
( Hi!
  ( How
    about
    using
    Lisp
    ( instead
      of
      .
      C?
    )
  )
)

> (Hi there) (How are you)
( Hi
  there
)

> ( How
  are
  you
)
         
> (Hi
           .
           (there  .(     ; note that there may be no space between
                          ; '.' and '('
           How is it going?))
           )
( Hi
  there
  How
  is
  it
  going?
)

> ; Note : We have just introduced the use of comments.
  ; ';' starts a comment until the end of line.
  ; A comment is something that ReadSExp() should skip when 
  ; reading in an S-expression.
  
(1 2 3) )
( 1
  2
  3
)

> ERROR (unexpected character) : line 1 column 2 character ')'

> (1 2 
   3) (4 5
( 1
  2
  3
)

>       6)
( 4
  5
  6
)

>        '(Hi
           .
           (there  .(     ; note that there may be no space between
                          ; '.' and '('
           How is it going?))
           )
( quote 
  ( Hi
    there
    How
    is
    it
    going?
  )
)

>'(1 2 3) )
( quote
  ( 1
    2
    3
  )
)

> ERROR (unexpected character) : line 1 column 2 character ')'

> '(1 2 3) .25
( quote
  ( 1
    2
    3
  )
)

> 0.250

> (exit  ; as of now, your system only understands 'exit' ;
      )  ; and the program terminates when it sees '(exit)'

Thanks for using OurScheme!





// =================== Project 1 I/O requirement ===========

Project 1 的I/O要求

你要寫的是一個interactive system。如果正常(在DOS視窗)跑，其運作跟Petite 
Chez Scheme的運作很像。其例如下(note that for the first project, you only
need to read in an S-expression and then print out an S-expression)：

  Welcome to OurScheme!
  
  > a   ; a line-comment starts with a ';', and continues until end-of-line
  a
  
  > 3   ; your system should be able to skip all line-comments
  3
  
  > (cons 3 5)  ; once it prints the output, it prints a blank line
  ( cons
    3
    5
  )
  
  >             ; the system first prints '> ', and then starts to get
                ; the user's input until either an unexpected character
     (    (     ; is encountered or the user has entered an S-expression
                ;
  Hi "!" How    ; note that the principle of "longest match preferred" 
                ; should be honored ; e.g., if the user enters 'How', 
  . "are you?"  ; you should get 'How' and not (just) 'H' or 'Ho' ;
  
        )   "Fine.  Thank you."
        
   )    ( 3 .   ; if, on the same line that the S-expression ends, the
  ( ( Hi
      "!"
      How
      .
      "are you?"
    )
    "Fine.  Thank you."
  )
  
  >             ; user also starts another input, then the
                ; system also starts processing the second input,
         .      ; but will print the output for the first input first
  ERROR (unexpected character) : line 4 column 8 character '.'
  
  > ( 1 2 ) ( 3 4 ) 5
  ( 1
    2
  )
  
  > ( 3
    4
  )
  
  > 5
  
  > ; the above is an example of how the system handles "multiple
    ; input on the same line"
    ; The point : the user may have already started entering input
    ;             BEFORE the system prints '> '
    
    (exit     ; this is the way to get out of user-system dialog ;
              ; below, there is a LINE-ENTER preceding 'Thanks' and
   )          ; two LINE-ENTER following '!'
  
  Thanks for using OurScheme!

// ===================================================

但PAL是用一個input檔來測你的系統，而且你的程式的output會"導"到
一個output檔去。所以，當PAL測試你的程式時，here is what really 
happens :

// input自下一行開始
1
a   ; a line-comment starts with a ';', and continues until end-of-line
3   ; your system should be able to skip all line-comments
(cons 3 5)  ; once it prints the output, it prints a blank line
            ; the system first prints '> ', and then starts to get
              ; the user's input until either an unexpected character
   (    (     ; is encountered or the user has entered an S-expression
              ;
Hi "!" How    ; note that the principle of "longest match preferred" 
              ; should be honored ; e.g., if the user enters 'How', 
. "are you?"  ; you should get 'How' and not (just) 'H' or 'Ho' ;

      )   "Fine.  Thank you."
      
 )    ( 3 .   ; if, on the same line that the S-expression ends, the
            ; user also starts another input, then the
              ; system also starts processing the second input,
       .      ; but will print the output for the first input first
( 1 2 ) ( 3 4 ) 5
; the above is an example of how the system handles "multiple
  ; input on the same line"
  ; The point : the user may have already started entering input
  ;             BEFORE the system prints '> '
  
  (exit     ; this is the way to get out of user-system dialog ;
            ; below, there is a LINE-ENTER preceding 'Thanks' and
 )          ; two LINE-ENTER following '!'
// input至上一行止



// output自下一行開始
Welcome to OurScheme!

> a

> 3

> ( cons
  3
  5
)

> ( ( Hi
    "!"
    How
    .
    "are you?"
  )
  "Fine.  Thank you."
)

> ERROR (unexpected character) : line 4 column 8 character '.'

> ( 1
  2
)

> ( 3
  4
)

> 5

> 
Thanks for using OurScheme!
// output至上一行止，而且不包括上一行的trailing white space(s)

註：
  For some unknown reason, PAL cannot get the "final white spaces" in your
  output.
  
  Therefore, in the "standard answer" that PAL uses to compare your output
  with, there are no "final white spaces" either.

// ===================================================

PAL的運作是這樣：

  它先compile你的程式，如果compile沒問題，它就用若干測試檔來測試你的程式。
  
  它先測第一個測試數據，也就是run你的程式、並以第一個測試檔作為input、同時也
  
  把你的程式的output"導"到一個output檔。
  
  若你的程式順利run完(祝福你！)，PAL就比對你的output檔與「標準答案檔」，
  
  若二者的內容有任何一點不同，PAL就到此為止，並說"你答錯了"(給看不給看則端視
  
  這是第幾個測試數據)。
  
  若二者的內容完全相同，PAL就用下一個測試檔再來一次(如果已經沒有測試檔了就
  
  "恭喜答對")。
  
  換句話說，有幾個測試檔、PAL就會run你的程式幾次(如果你都過的話)。
  
  如果在run你的程式的(這麼多次的)過程之中有"疑似無窮迴圈"或發生exception，
  
  PAL就到此為止，並通知你。

// ===================================================

gTestNum ( 或 uTestNum ) :

  為了幫助你debug，所有的測試數據的一開始都有個integer (it has no preceding
  
  white-spaces, and is immediately followed by a LINE-ENTER character)，
  
  此integer代表著"目前這個測試數據是第幾個測試數據"。你應該用一個global或
  
  file-scope的變數來存這個integer。此integer對於你的debug工作將會很有幫助。
  
  (程式一開始就讀它(此test number保證存在)，然後想辦法(if you want)"跳過"
  
   其後的LINE-ENTER，再開始你的任何"正常processing"。)

// ===================================================

OurScheme的I/O規矩：

  ※ 基本的I/O規矩請由以上的I/O範例推導
  
  ※ 基本上，(syntax) error的發生、在於(OurScheme)系統讀到"不該出現的字元"，
     
     當這狀況發生時，(OurScheme)系統應該知道此字元的line與column，
     
     從而印出如範例中所示的
  
       ERROR (unexpected character) : line 4 column 8 character '.'  

     但有一個狀況比較特殊(事實上有多種，我們只考慮這種)，那就是string
     
     還沒"close"就已出現LINE-ENTER。例： // 假設'('是column 1
                                         // 第一行共18字元(不計LINE-ENTER)
             ( cons "Hi" "How  
                   are you" )
     
     此時要印的是
     
       ERROR (unexpected character) : line 1 column 19 LINE-ENTER encountered

  ※ 一旦發生unexpected character錯誤，該行就完全skip，
  
     系統會把使用者的下一行視為(系統印出)'> '之後的input。

  ※ 印S-expression的規矩列於本文最後。

  ※ 一旦已process到使用者所enter的'(exit)'，之後在input檔中若還有任何
     
     使用者input，系統都不須也不該理會。

  ※ 由於是用input檔給input、而不是interactive I/O，所以有可能發生「使用者
  
     還沒input完一個S-expression就沒input了」的狀況，
     
     此時系統應該要print如下的message :
     
       ERROR : END-OF-FILE encountered when there should be more input
       
       Thanks for using OurScheme!
       
// ===================================================

Rules for printing an S-expression s

if s is an atom
  then print s with no leading white space and with one trailing '\n'
       note : For 'nil', '()' and '#f', always print 'nil'.
       note : For '#t' and 't', always print '#t'.
       
else { // s is of the form : '(' s1 s2 ... sn [ '.' snn ] ')'

  let M be the number of characters that are already 
      printed on the current line
      
  print '(', print one space, print s1
  print M+2 spaces, print s2
  ...
  print M+2 spaces, print sn
  if there are '.' and snn following sn
    print M+2 spaces, print '.', print '\n'
    print M+2 spaces, print snn
  print M spaces, print ')', print '\n'
  
} // else s is of the form : '(' s1 s2 ... sn [ '.' snn ] ')'


Example : 

  (((1 . 2) (3 4) 5 . 6) 7 . 8)
  
  should be printed as // output之中的各行的前兩個space不算
  
  // output starts from the next line
  ( ( ( 1
        .
        2
      )
      ( 3
        4
      )
      5
      .
      6
    )
    7
    .
    8
  )
  // output terminates here, and does not include this line
  // all lines in the output have no trailing spaces or tabs

Example : 

  (((1 . "ICE CYCU") (THIS is (41 42 . 43)) Chung . Yuan) 7 . 8)
  
  should be printed as // output之中的各行的前兩個space不算
  
  // output starts from the next line
  ( ( ( 1
        .
        "ICE CYCU"
      )
      ( THIS
        is
        ( 41
          42
          .
          43
        )
      )
      Chung
      .
      Yuan
    )
    7
    .
    8
  )
  // output terminates here, and does not include this line
  // all lines in the output have no trailing spaces or tabs




// =================== Q and A No. 1 =======================

Question : '(1 2 3)的output應該是什麼？

Answer :

Project 1 :

> '(1 2 3)
( quote
  ( 1
    2
    3
  )
)


Project 2 :

> '(1 2 3)
( 1
  2
  3
)

解釋：

Project 1只讀進來(建出DS)、不evaluate就直接(把DS)印出去，
所以得 : (quote (1 2 3))。

Project 2是讀進來(建出DS)、evaluate(此DS)、再把evaluate的result
(依舊是個DS)印出去，所以得 : (1 2 3)。

(將'(quote (1 2 3))'予以evaluate所得的結果是'(1 2 3)')



// =================== Q and A No. 2 =======================

※ 引述《...》之銘言：

> 請問老大~~

> 1.當輸入'> .'時，會是ERROR嗎???
>   若是是ERROR.msg：會是column: 1 or 2 ???

   It is an error.  (Let us suppose that it is '> .$', where '$' is
   LINE-ENTER char.)

   column : 2   '.' is the very first user input char
                on this line.  (the space before it is system output)

   Why column 2 and not column 1? Please see my answer to your second

   question below. (The system detects an error when it sees the LINE-

   ENTER char.)

> 2.在測試數據中有輸入(12.5)(12(. 3))

> 答案是:

> > ( 12.500
> )
> > ERROR (unexpected character) : line 1 column 6 character ' '

> 但是在OurScheme中

> > (12 (    . 3))
> ERROR (unexpected character) : line 1 column 10 character '.'

> 之前的input是'.'錯，現在的input則是' '錯，為什麼呢???

In the case of (the first one) '(12(. 3))', everything is still

OK when the system (i.e., your system) "sees" '.'.  Why?  Because '.'

may be followed by a digit such as '5'.  The system detects an error

only when it sees that there is a space following '.'.  Therefore, the

"error char" (the char that caused the error) is the space and not the '.'


In the case of (the second one) '(12 (    . 3))', the error char should

also be the space-char following that '.'   You just found an error in my

Project 1 handout.  Thank you.  (And I have taken the liberty to

correct this error in both OurSchemeProj1.txt and HowToWriteOurScheme.doc)


> 3.請問abc"abc會印出什麼呢???

  The first token is 'abc'. The second token is a string that starts

  with : "abc

  e.g., // for project 1

  > abc"abc   "
  abc

  > "abc   "

→ yabuki 推：老大那abc'abc算是symbol嗎?還是會有其他結果?        03/09 22:27
→ hsia 推：the case of abc'abc similar to the above case,       03/10 08:57
→ hsia 推：because single-quote, double-quote R separators      03/10 08:58



// =================== Q and A No. 3 =======================

※ 引述《...》之銘言：

> 這問題困擾很久百思不得其解。

>
> 依題意應該是最後一個可以執行（或印出）的Token後將行號和欄位初始化
> 範例如下

> ()   )
>  ^這玩意兒是最後的token，所以要印出在line 1錯

> 問題來了：
> "最後一個字串"\n
> \n
>   \n
> "出錯點

> 為什麼這裡印line 3？把最後一個字串token拿掉後應該如下
> \n　　　　　　　　　　　　　　１
> \n                            ２
>   \n                          ３
> "出錯點                     第４行
> ---------------

> "最後一個字串"　　　　　　\n　１
> \n                            ２
>   \n                          ３
> "出錯點                       ４

> 加了空白為什麼也是line 3？

這沒什麼好百思不得其解的。 這是規劃時的思緒不夠細密。

的確，嚴格來講、按照規定、最後一個case的error應是第四行、而非第三行。

當初規劃時未考慮到「在legal input之後若還有(也只有)space怎麼算下一input的行數」

的問題。

不過，你就當這case是「general規定」的exception吧，意即：



  在legal input之後(同一行)要出現「下一個input S-expression的有效字元」，
  才把這一行算作是下一input的第一行。  若legal input之後(同一行)只出現
 「space或tab或註解」，那這一行就不算作是下一input的第一行。



※ 引述《...》之銘言：
> 請問一下PAL的proj2數據，當指令為(exit)時，output為
> 
> Thanks for using OurScheme!

> 為什麼不是
> Thanks for using OurScheme!

> 是不是要print "\nThanks for using OurScheme!"
> 謝謝

答案是：

  Project要求

  > (     ;; user input, with an ENTER at the end
          ;; user input, with an ENTER at the end
    exit  ;; user input, with an ENTER at the end
          ;; user input, with an ENTER at the end
       )  ;; user input, with an ENTER at the end

  Thanks for using OurScheme!;; system output













